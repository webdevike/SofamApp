{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _AnimatedAlways = require(\"./AnimatedAlways\");\n\nvar _AnimatedNode = _interopRequireDefault(require(\"./AnimatedNode\"));\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar Code = function (_React$PureComponent) {\n  (0, _inherits2.default)(Code, _React$PureComponent);\n\n  var _super = _createSuper(Code);\n\n  function Code() {\n    (0, _classCallCheck2.default)(this, Code);\n    return _super.apply(this, arguments);\n  }\n\n  (0, _createClass2.default)(Code, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props = this.props,\n          children = _this$props.children,\n          exec = _this$props.exec;\n      var nodeChildren = Code.resolveNode(children);\n      var nodeExec = Code.resolveNode(exec);\n      var cantResolveNode = nodeChildren === null && nodeExec === null;\n\n      if (cantResolveNode) {\n        var error = nodeChildren === null ? \"Got \\\"\" + typeof children + \"\\\" type passed to children\" : \"Got \\\"\" + typeof exec + \"\\\" type passed to exec\";\n        throw new Error(\"<Animated.Code /> expects the 'exec' prop or children to be an animated node or a function returning an animated node. \" + error);\n      }\n\n      this.always = (0, _AnimatedAlways.createAnimatedAlways)(nodeExec || nodeChildren);\n\n      this.always.__attach();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.always.__detach();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.componentWillUnmount();\n      this.componentDidMount();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return null;\n    }\n  }]);\n  return Code;\n}(_react.default.PureComponent);\n\nCode.resolveNode = function (maybeNode) {\n  if (typeof maybeNode === 'function') {\n    return Code.resolveNode(maybeNode());\n  }\n\n  if (maybeNode instanceof _AnimatedNode.default) {\n    return maybeNode;\n  }\n\n  return null;\n};\n\nvar _default = Code;\nexports.default = _default;","map":{"version":3,"sources":["/Users/isaacweber/code/SofamApp/node_modules/react-native-reanimated/src/core/AnimatedCode.js"],"names":["Code","props","children","exec","nodeChildren","resolveNode","nodeExec","cantResolveNode","error","Error","always","__attach","__detach","componentWillUnmount","componentDidMount","React","PureComponent","maybeNode","AnimatedNode"],"mappings":";;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;;;;;IAEMA,I;;;;;;;;;;;;wCAagB;AAAA,wBACS,KAAKC,KADd;AAAA,UACVC,QADU,eACVA,QADU;AAAA,UACAC,IADA,eACAA,IADA;AAElB,UAAMC,YAAY,GAAGJ,IAAI,CAACK,WAAL,CAAiBH,QAAjB,CAArB;AACA,UAAMI,QAAQ,GAAGN,IAAI,CAACK,WAAL,CAAiBF,IAAjB,CAAjB;AAEA,UAAMI,eAAe,GAAGH,YAAY,KAAK,IAAjB,IAAyBE,QAAQ,KAAK,IAA9D;;AAEA,UAAIC,eAAJ,EAAqB;AACnB,YAAMC,KAAK,GACTJ,YAAY,KAAK,IAAjB,cACY,OAAOF,QADnB,6CAEY,OAAOC,IAFnB,2BADF;AAKA,cAAM,IAAIM,KAAJ,6HACsHD,KADtH,CAAN;AAGD;;AAED,WAAKE,MAAL,GAAc,0CAAqBJ,QAAQ,IAAIF,YAAjC,CAAd;;AACA,WAAKM,MAAL,CAAYC,QAAZ;AACD;;;2CAEsB;AACrB,WAAKD,MAAL,CAAYE,QAAZ;AACD;;;yCAEoB;AACnB,WAAKC,oBAAL;AACA,WAAKC,iBAAL;AACD;;;6BAEQ;AACP,aAAO,IAAP;AACD;;;EA9CgBC,eAAMC,a;;AAAnBhB,I,CACGK,W,GAAc,UAAAY,SAAS,EAAI;AAChC,MAAI,OAAOA,SAAP,KAAqB,UAAzB,EAAqC;AACnC,WAAOjB,IAAI,CAACK,WAAL,CAAiBY,SAAS,EAA1B,CAAP;AACD;;AAED,MAAIA,SAAS,YAAYC,qBAAzB,EAAuC;AACrC,WAAOD,SAAP;AACD;;AAED,SAAO,IAAP;AACD,C;;eAqCYjB,I","sourcesContent":["import React from 'react';\nimport { createAnimatedAlways } from './AnimatedAlways';\nimport AnimatedNode from './AnimatedNode';\n\nclass Code extends React.PureComponent {\n  static resolveNode = maybeNode => {\n    if (typeof maybeNode === 'function') {\n      return Code.resolveNode(maybeNode());\n    }\n\n    if (maybeNode instanceof AnimatedNode) {\n      return maybeNode;\n    }\n\n    return null;\n  };\n\n  componentDidMount() {\n    const { children, exec } = this.props;\n    const nodeChildren = Code.resolveNode(children);\n    const nodeExec = Code.resolveNode(exec);\n\n    const cantResolveNode = nodeChildren === null && nodeExec === null;\n\n    if (cantResolveNode) {\n      const error =\n        nodeChildren === null\n          ? `Got \"${typeof children}\" type passed to children`\n          : `Got \"${typeof exec}\" type passed to exec`;\n\n      throw new Error(\n        `<Animated.Code /> expects the 'exec' prop or children to be an animated node or a function returning an animated node. ${error}`\n      );\n    }\n\n    this.always = createAnimatedAlways(nodeExec || nodeChildren);\n    this.always.__attach();\n  }\n\n  componentWillUnmount() {\n    this.always.__detach();\n  }\n  \n  componentDidUpdate() {\n    this.componentWillUnmount();\n    this.componentDidMount();\n  }\n  \n  render() {\n    return null;\n  }\n}\nexport default Code;\n"]},"metadata":{},"sourceType":"script"}