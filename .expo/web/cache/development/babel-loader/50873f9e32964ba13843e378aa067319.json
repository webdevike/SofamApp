{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPermissionsAsync = getPermissionsAsync;\nexports.requestPermissionsAsync = requestPermissionsAsync;\nObject.defineProperty(exports, \"PermissionStatus\", {\n  enumerable: true,\n  get: function get() {\n    return _unimodulesPermissionsInterface.PermissionStatus;\n  }\n});\nexports.Recording = exports.RECORDING_OPTIONS_PRESET_LOW_QUALITY = exports.RECORDING_OPTIONS_PRESET_HIGH_QUALITY = exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE = exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED = exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE = exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4 = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _core = require(\"@unimodules/core\");\n\nvar _unimodulesPermissionsInterface = require(\"unimodules-permissions-interface\");\n\nvar _AV = require(\"../AV\");\n\nvar _ExponentAV = _interopRequireDefault(require(\"../ExponentAV\"));\n\nvar _AudioAvailability = require(\"./AudioAvailability\");\n\nvar _Sound = require(\"./Sound\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT = 0;\nexports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT = RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT;\nvar RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP = 1;\nexports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP = RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP;\nvar RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4 = 2;\nexports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4 = RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4;\nvar RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB = 3;\nexports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB = RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB;\nvar RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB = 4;\nexports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB = RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB;\nvar RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF = 5;\nexports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF = RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF;\nvar RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS = 6;\nexports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS = RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS;\nvar RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP = 7;\nexports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP = RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP;\nvar RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS = 8;\nexports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS = RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS;\nvar RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM = 9;\nexports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM = RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM;\nvar RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT = 0;\nexports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT = RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT;\nvar RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB = 1;\nexports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB = RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB;\nvar RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB = 2;\nexports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB = RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB;\nvar RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC = 3;\nexports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC = RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC;\nvar RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC = 4;\nexports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC = RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC;\nvar RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD = 5;\nexports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD = RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM = 'lpcm';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM = RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3 = 'ac-3';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3 = RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3 = 'cac3';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3 = RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4 = 'ima4';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4 = RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC = 'aac ';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC = RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP = 'celp';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP = RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC = 'hvxc';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC = RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ = 'twvq';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ = RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3 = 'MAC3';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3 = RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6 = 'MAC6';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6 = RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW = 'ulaw';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW = RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW = 'alaw';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW = RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN = 'QDMC';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN = RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2 = 'QDM2';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2 = RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM = 'Qclp';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM = RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1 = '.mp1';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1 = RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2 = '.mp2';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2 = RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3 = '.mp3';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3 = RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS = 'alac';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS = RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE = 'aach';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE = RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD = 'aacl';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD = RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD = 'aace';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD = RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR = 'aacf';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR = RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2 = 'aacg';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2 = RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2 = 'aacp';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2 = RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL = 'aacs';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL = RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR = 'samr';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR = RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB = 'sawb';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB = RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE = 'AUDB';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE = RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC = 'ilbc';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC = RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA = 0x6d730011;\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA = RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM = 0x6d730031;\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM = RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3 = 'aes3';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3 = RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3;\nvar RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3 = 'ec-3';\nexports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3 = RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3;\nvar RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN = 0;\nexports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN = RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN;\nvar RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW = 0x20;\nexports.RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW = RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW;\nvar RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM = 0x40;\nexports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM = RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM;\nvar RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH = 0x60;\nexports.RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH = RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH;\nvar RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX = 0x7f;\nexports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX = RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX;\nvar RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT = 0;\nexports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT = RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT;\nvar RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE = 1;\nexports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE = RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE;\nvar RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED = 2;\nexports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED = RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED;\nvar RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE = 3;\nexports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE = RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE;\nvar RECORDING_OPTIONS_PRESET_HIGH_QUALITY = {\n  android: {\n    extension: '.m4a',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false\n  }\n};\nexports.RECORDING_OPTIONS_PRESET_HIGH_QUALITY = RECORDING_OPTIONS_PRESET_HIGH_QUALITY;\nvar RECORDING_OPTIONS_PRESET_LOW_QUALITY = {\n  android: {\n    extension: '.3gp',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false\n  }\n};\nexports.RECORDING_OPTIONS_PRESET_LOW_QUALITY = RECORDING_OPTIONS_PRESET_LOW_QUALITY;\nvar _recorderExists = false;\nvar eventEmitter = _core.Platform.OS === 'android' ? new _core.EventEmitter(_ExponentAV.default) : null;\n\nfunction getPermissionsAsync() {\n  return _regenerator.default.async(function getPermissionsAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          return _context.abrupt(\"return\", _ExponentAV.default.getPermissionsAsync());\n\n        case 1:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction requestPermissionsAsync() {\n  return _regenerator.default.async(function requestPermissionsAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          return _context2.abrupt(\"return\", _ExponentAV.default.requestPermissionsAsync());\n\n        case 1:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nvar Recording = function () {\n  function Recording() {\n    var _this = this;\n\n    (0, _classCallCheck2.default)(this, Recording);\n    this._subscription = null;\n    this._canRecord = false;\n    this._isDoneRecording = false;\n    this._finalDurationMillis = 0;\n    this._uri = null;\n    this._onRecordingStatusUpdate = null;\n    this._progressUpdateTimeoutVariable = null;\n    this._progressUpdateIntervalMillis = _AV._DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n    this._options = null;\n\n    this._cleanupForUnloadedRecorder = function _callee(finalStatus) {\n      return _regenerator.default.async(function _callee$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _this._canRecord = false;\n              _this._isDoneRecording = true;\n              _this._finalDurationMillis = finalStatus.durationMillis;\n              _recorderExists = false;\n\n              if (_this._subscription) {\n                _this._subscription.remove();\n\n                _this._subscription = null;\n              }\n\n              _this._disablePolling();\n\n              _context3.next = 8;\n              return _regenerator.default.awrap(_this.getStatusAsync());\n\n            case 8:\n              return _context3.abrupt(\"return\", _context3.sent);\n\n            case 9:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    };\n\n    this._pollingLoop = function _callee2() {\n      return _regenerator.default.async(function _callee2$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!((0, _AudioAvailability.isAudioEnabled)() && _this._canRecord && _this._onRecordingStatusUpdate != null)) {\n                _context4.next = 10;\n                break;\n              }\n\n              _this._progressUpdateTimeoutVariable = setTimeout(_this._pollingLoop, _this._progressUpdateIntervalMillis);\n              _context4.prev = 2;\n              _context4.next = 5;\n              return _regenerator.default.awrap(_this.getStatusAsync());\n\n            case 5:\n              _context4.next = 10;\n              break;\n\n            case 7:\n              _context4.prev = 7;\n              _context4.t0 = _context4[\"catch\"](2);\n\n              _this._disablePolling();\n\n            case 10:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, null, [[2, 7]], Promise);\n    };\n\n    this.getStatusAsync = function _callee3() {\n      var status;\n      return _regenerator.default.async(function _callee3$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!_this._canRecord) {\n                _context5.next = 2;\n                break;\n              }\n\n              return _context5.abrupt(\"return\", _this._performOperationAndHandleStatusAsync(function () {\n                return _ExponentAV.default.getAudioRecordingStatus();\n              }));\n\n            case 2:\n              status = {\n                canRecord: false,\n                isRecording: false,\n                isDoneRecording: _this._isDoneRecording,\n                durationMillis: _this._finalDurationMillis\n              };\n\n              _this._callOnRecordingStatusUpdateForNewStatus(status);\n\n              return _context5.abrupt(\"return\", status);\n\n            case 5:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    };\n  }\n\n  (0, _createClass2.default)(Recording, [{\n    key: \"_disablePolling\",\n    value: function _disablePolling() {\n      if (this._progressUpdateTimeoutVariable != null) {\n        clearTimeout(this._progressUpdateTimeoutVariable);\n        this._progressUpdateTimeoutVariable = null;\n      }\n    }\n  }, {\n    key: \"_enablePollingIfNecessaryAndPossible\",\n    value: function _enablePollingIfNecessaryAndPossible() {\n      if ((0, _AudioAvailability.isAudioEnabled)() && this._canRecord && this._onRecordingStatusUpdate != null) {\n        this._disablePolling();\n\n        this._pollingLoop();\n      }\n    }\n  }, {\n    key: \"_callOnRecordingStatusUpdateForNewStatus\",\n    value: function _callOnRecordingStatusUpdateForNewStatus(status) {\n      if (this._onRecordingStatusUpdate != null) {\n        this._onRecordingStatusUpdate(status);\n      }\n    }\n  }, {\n    key: \"_performOperationAndHandleStatusAsync\",\n    value: function _performOperationAndHandleStatusAsync(operation) {\n      var status;\n      return _regenerator.default.async(function _performOperationAndHandleStatusAsync$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              (0, _AudioAvailability.throwIfAudioIsDisabled)();\n\n              if (!this._canRecord) {\n                _context6.next = 9;\n                break;\n              }\n\n              _context6.next = 4;\n              return _regenerator.default.awrap(operation());\n\n            case 4:\n              status = _context6.sent;\n\n              this._callOnRecordingStatusUpdateForNewStatus(status);\n\n              return _context6.abrupt(\"return\", status);\n\n            case 9:\n              throw new Error('Cannot complete operation because this recorder is not ready to record.');\n\n            case 10:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"setOnRecordingStatusUpdate\",\n    value: function setOnRecordingStatusUpdate(onRecordingStatusUpdate) {\n      this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n\n      if (onRecordingStatusUpdate == null) {\n        this._disablePolling();\n      } else {\n        this._enablePollingIfNecessaryAndPossible();\n      }\n\n      this.getStatusAsync();\n    }\n  }, {\n    key: \"setProgressUpdateInterval\",\n    value: function setProgressUpdateInterval(progressUpdateIntervalMillis) {\n      this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n      this.getStatusAsync();\n    }\n  }, {\n    key: \"prepareToRecordAsync\",\n    value: function prepareToRecordAsync() {\n      var options,\n          extensionRegex,\n          _await$ExponentAV$pre,\n          uri,\n          status,\n          currentStatus,\n          _args7 = arguments;\n\n      return _regenerator.default.async(function prepareToRecordAsync$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              options = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : RECORDING_OPTIONS_PRESET_LOW_QUALITY;\n              (0, _AudioAvailability.throwIfAudioIsDisabled)();\n\n              if (!_recorderExists) {\n                _context7.next = 4;\n                break;\n              }\n\n              throw new Error('Only one Recording object can be prepared at a given time.');\n\n            case 4:\n              if (!this._isDoneRecording) {\n                _context7.next = 6;\n                break;\n              }\n\n              throw new Error('This Recording object is done recording; you must make a new one.');\n\n            case 6:\n              if (!(!options || !options.android || !options.ios)) {\n                _context7.next = 8;\n                break;\n              }\n\n              throw new Error('You must provide recording options for android and ios in order to prepare to record.');\n\n            case 8:\n              extensionRegex = /^\\.\\w+$/;\n\n              if (!(!options.android.extension || !options.ios.extension || !extensionRegex.test(options.android.extension) || !extensionRegex.test(options.ios.extension))) {\n                _context7.next = 11;\n                break;\n              }\n\n              throw new Error(\"Your file extensions must match \" + extensionRegex.toString() + \".\");\n\n            case 11:\n              if (this._canRecord) {\n                _context7.next = 28;\n                break;\n              }\n\n              if (eventEmitter) {\n                this._subscription = eventEmitter.addListener('Expo.Recording.recorderUnloaded', this._cleanupForUnloadedRecorder);\n              }\n\n              _context7.next = 15;\n              return _regenerator.default.awrap(_ExponentAV.default.prepareAudioRecorder(options));\n\n            case 15:\n              _await$ExponentAV$pre = _context7.sent;\n              uri = _await$ExponentAV$pre.uri;\n              status = _await$ExponentAV$pre.status;\n              _recorderExists = true;\n              this._uri = uri;\n              this._options = options;\n              this._canRecord = true;\n              currentStatus = _objectSpread(_objectSpread({}, status), {}, {\n                canRecord: true\n              });\n\n              this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n\n              this._enablePollingIfNecessaryAndPossible();\n\n              return _context7.abrupt(\"return\", currentStatus);\n\n            case 28:\n              throw new Error('This Recording object is already prepared to record.');\n\n            case 29:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"startAsync\",\n    value: function startAsync() {\n      return _regenerator.default.async(function startAsync$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              return _context8.abrupt(\"return\", this._performOperationAndHandleStatusAsync(function () {\n                return _ExponentAV.default.startAudioRecording();\n              }));\n\n            case 1:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"pauseAsync\",\n    value: function pauseAsync() {\n      return _regenerator.default.async(function pauseAsync$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              return _context9.abrupt(\"return\", this._performOperationAndHandleStatusAsync(function () {\n                return _ExponentAV.default.pauseAudioRecording();\n              }));\n\n            case 1:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"stopAndUnloadAsync\",\n    value: function stopAndUnloadAsync() {\n      var finalStatus;\n      return _regenerator.default.async(function stopAndUnloadAsync$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              if (this._canRecord) {\n                _context10.next = 6;\n                break;\n              }\n\n              if (!this._isDoneRecording) {\n                _context10.next = 5;\n                break;\n              }\n\n              throw new Error('Cannot unload a Recording that has already been unloaded.');\n\n            case 5:\n              throw new Error('Cannot unload a Recording that has not been prepared.');\n\n            case 6:\n              _context10.next = 8;\n              return _regenerator.default.awrap(_ExponentAV.default.stopAudioRecording());\n\n            case 8:\n              finalStatus = _context10.sent;\n              _context10.next = 11;\n              return _regenerator.default.awrap(_ExponentAV.default.unloadAudioRecorder());\n\n            case 11:\n              return _context10.abrupt(\"return\", this._cleanupForUnloadedRecorder(finalStatus));\n\n            case 12:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"getURI\",\n    value: function getURI() {\n      return this._uri;\n    }\n  }, {\n    key: \"createNewLoadedSound\",\n    value: function createNewLoadedSound() {\n      var initialStatus,\n          onPlaybackStatusUpdate,\n          _args11 = arguments;\n      return _regenerator.default.async(function createNewLoadedSound$(_context11) {\n        while (1) {\n          switch (_context11.prev = _context11.next) {\n            case 0:\n              initialStatus = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : {};\n              onPlaybackStatusUpdate = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : null;\n              console.warn(\"createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name\");\n              return _context11.abrupt(\"return\", this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate));\n\n            case 4:\n            case \"end\":\n              return _context11.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"createNewLoadedSoundAsync\",\n    value: function createNewLoadedSoundAsync() {\n      var initialStatus,\n          onPlaybackStatusUpdate,\n          _args12 = arguments;\n      return _regenerator.default.async(function createNewLoadedSoundAsync$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              initialStatus = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : {};\n              onPlaybackStatusUpdate = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : null;\n\n              if (!(this._uri == null || !this._isDoneRecording)) {\n                _context12.next = 4;\n                break;\n              }\n\n              throw new Error('Cannot create sound when the Recording has not finished!');\n\n            case 4:\n              return _context12.abrupt(\"return\", _Sound.Sound.createAsync({\n                uri: this._uri\n              }, initialStatus, onPlaybackStatusUpdate, false));\n\n            case 5:\n            case \"end\":\n              return _context12.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n  return Recording;\n}();\n\nexports.Recording = Recording;","map":{"version":3,"sources":["../../src/Audio/Recording.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter, Subscription, Platform } from '@unimodules/core';\nimport { PermissionResponse, PermissionStatus } from 'unimodules-permissions-interface';\n\nimport {\n  _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n} from '../AV';\nimport ExponentAV from '../ExponentAV';\nimport { isAudioEnabled, throwIfAudioIsDisabled } from './AudioAvailability';\nimport { Sound } from './Sound';\n\nexport type RecordingOptions = {\n  android: {\n    extension: string;\n    outputFormat: number;\n    audioEncoder: number;\n    sampleRate?: number;\n    numberOfChannels?: number;\n    bitRate?: number;\n    maxFileSize?: number;\n  };\n  ios: {\n    extension: string;\n    outputFormat?: string | number;\n    audioQuality: number;\n    sampleRate: number;\n    numberOfChannels: number;\n    bitRate: number;\n    bitRateStrategy?: number;\n    bitDepthHint?: number;\n    linearPCMBitDepth?: number;\n    linearPCMIsBigEndian?: boolean;\n    linearPCMIsFloat?: boolean;\n  };\n};\n\n// TODO: consider changing these to enums\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT = 0;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP = 1;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4 = 2;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB = 3;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB = 4;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF = 5;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS = 6;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP = 7;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS = 8;\nexport const RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM = 9;\n\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT = 0;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB = 1;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB = 2;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC = 3;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC = 4;\nexport const RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD = 5;\n\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM = 'lpcm';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3 = 'ac-3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3 = 'cac3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4 = 'ima4';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC = 'aac ';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP = 'celp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC = 'hvxc';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ = 'twvq';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3 = 'MAC3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6 = 'MAC6';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW = 'ulaw';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW = 'alaw';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN = 'QDMC';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2 = 'QDM2';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM = 'Qclp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1 = '.mp1';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2 = '.mp2';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3 = '.mp3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS = 'alac';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE = 'aach';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD = 'aacl';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD = 'aace';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR = 'aacf';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2 = 'aacg';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2 = 'aacp';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL = 'aacs';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR = 'samr';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB = 'sawb';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE = 'AUDB';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC = 'ilbc';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA = 0x6d730011;\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM = 0x6d730031;\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3 = 'aes3';\nexport const RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3 = 'ec-3';\n\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN = 0;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW = 0x20;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM = 0x40;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH = 0x60;\nexport const RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX = 0x7f;\n\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT = 0;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE = 1;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED = 2;\nexport const RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE = 3;\n\n// TODO : maybe make presets for music and speech, or lossy / lossless.\n\nexport const RECORDING_OPTIONS_PRESET_HIGH_QUALITY: RecordingOptions = {\n  android: {\n    extension: '.m4a',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false,\n  },\n};\n\nexport const RECORDING_OPTIONS_PRESET_LOW_QUALITY: RecordingOptions = {\n  android: {\n    extension: '.3gp',\n    outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP,\n    audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n  },\n  ios: {\n    extension: '.caf',\n    audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN,\n    sampleRate: 44100,\n    numberOfChannels: 2,\n    bitRate: 128000,\n    linearPCMBitDepth: 16,\n    linearPCMIsBigEndian: false,\n    linearPCMIsFloat: false,\n  },\n};\n\n// TODO: For consistency with PlaybackStatus, should we include progressUpdateIntervalMillis here as\n// well?\nexport type RecordingStatus = {\n  canRecord: boolean;\n  isRecording: boolean;\n  isDoneRecording: boolean;\n  durationMillis: number;\n};\n\nexport { PermissionResponse, PermissionStatus };\n\nlet _recorderExists: boolean = false;\nconst eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\n\nexport async function getPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.getPermissionsAsync();\n}\n\nexport async function requestPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.requestPermissionsAsync();\n}\n\nexport class Recording {\n  _subscription: Subscription | null = null;\n  _canRecord: boolean = false;\n  _isDoneRecording: boolean = false;\n  _finalDurationMillis: number = 0;\n  _uri: string | null = null;\n  _onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null;\n  _progressUpdateTimeoutVariable: number | null = null;\n  _progressUpdateIntervalMillis: number = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n  _options: RecordingOptions | null = null;\n\n  // Internal methods\n\n  _cleanupForUnloadedRecorder = async (finalStatus: RecordingStatus) => {\n    this._canRecord = false;\n    this._isDoneRecording = true;\n    // $FlowFixMe(greg): durationMillis is not always defined\n    this._finalDurationMillis = finalStatus.durationMillis;\n    _recorderExists = false;\n    if (this._subscription) {\n      this._subscription.remove();\n      this._subscription = null;\n    }\n    this._disablePolling();\n    return await this.getStatusAsync(); // Automatically calls onRecordingStatusUpdate for the final state.\n  };\n\n  _pollingLoop = async () => {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._progressUpdateTimeoutVariable = setTimeout(\n        this._pollingLoop,\n        this._progressUpdateIntervalMillis\n      ) as any;\n      try {\n        await this.getStatusAsync();\n      } catch (error) {\n        this._disablePolling();\n      }\n    }\n  };\n\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n\n  _enablePollingIfNecessaryAndPossible() {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._disablePolling();\n      this._pollingLoop();\n    }\n  }\n\n  _callOnRecordingStatusUpdateForNewStatus(status: RecordingStatus) {\n    if (this._onRecordingStatusUpdate != null) {\n      this._onRecordingStatusUpdate(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<RecordingStatus>\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n    if (this._canRecord) {\n      const status = await operation();\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because this recorder is not ready to record.');\n    }\n  }\n\n  // Note that all calls automatically call onRecordingStatusUpdate as a side effect.\n\n  // Get status API\n\n  getStatusAsync = async (): Promise<RecordingStatus> => {\n    // Automatically calls onRecordingStatusUpdate.\n    if (this._canRecord) {\n      return this._performOperationAndHandleStatusAsync(() => ExponentAV.getAudioRecordingStatus());\n    }\n    const status = {\n      canRecord: false,\n      isRecording: false,\n      isDoneRecording: this._isDoneRecording,\n      durationMillis: this._finalDurationMillis,\n    };\n    this._callOnRecordingStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  setOnRecordingStatusUpdate(onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null) {\n    this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n    if (onRecordingStatusUpdate == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n    this.getStatusAsync();\n  }\n\n  setProgressUpdateInterval(progressUpdateIntervalMillis: number) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  }\n\n  // Record API\n\n  async prepareToRecordAsync(\n    options: RecordingOptions = RECORDING_OPTIONS_PRESET_LOW_QUALITY\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n\n    if (_recorderExists) {\n      throw new Error('Only one Recording object can be prepared at a given time.');\n    }\n\n    if (this._isDoneRecording) {\n      throw new Error('This Recording object is done recording; you must make a new one.');\n    }\n\n    if (!options || !options.android || !options.ios) {\n      throw new Error(\n        'You must provide recording options for android and ios in order to prepare to record.'\n      );\n    }\n\n    const extensionRegex = /^\\.\\w+$/;\n    if (\n      !options.android.extension ||\n      !options.ios.extension ||\n      !extensionRegex.test(options.android.extension) ||\n      !extensionRegex.test(options.ios.extension)\n    ) {\n      throw new Error(`Your file extensions must match ${extensionRegex.toString()}.`);\n    }\n\n    if (!this._canRecord) {\n      if (eventEmitter) {\n        this._subscription = eventEmitter.addListener(\n          'Expo.Recording.recorderUnloaded',\n          this._cleanupForUnloadedRecorder\n        );\n      }\n\n      const {\n        uri,\n        status,\n      }: {\n        uri: string;\n        // status is of type RecordingStatus, but without the canRecord field populated\n        status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n      } = await ExponentAV.prepareAudioRecorder(options);\n\n      _recorderExists = true;\n      this._uri = uri;\n      this._options = options;\n      this._canRecord = true;\n\n      const currentStatus = { ...status, canRecord: true };\n      this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n      this._enablePollingIfNecessaryAndPossible();\n      return currentStatus;\n    } else {\n      throw new Error('This Recording object is already prepared to record.');\n    }\n  }\n\n  async startAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.startAudioRecording());\n  }\n\n  async pauseAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.pauseAudioRecording());\n  }\n\n  async stopAndUnloadAsync(): Promise<RecordingStatus> {\n    if (!this._canRecord) {\n      if (this._isDoneRecording) {\n        throw new Error('Cannot unload a Recording that has already been unloaded.');\n      } else {\n        throw new Error('Cannot unload a Recording that has not been prepared.');\n      }\n    }\n    // We perform a separate native API call so that the state of the Recording can be updated with\n    // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n    const finalStatus = await ExponentAV.stopAudioRecording();\n    await ExponentAV.unloadAudioRecorder();\n    return this._cleanupForUnloadedRecorder(finalStatus);\n  }\n\n  // Read API\n\n  getURI(): string | null {\n    return this._uri;\n  }\n\n  async createNewLoadedSound(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<{ sound: Sound; status: AVPlaybackStatus }> {\n    console.warn(\n      `createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name`\n    );\n    return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n  }\n\n  async createNewLoadedSoundAsync(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<{ sound: Sound; status: AVPlaybackStatus }> {\n    if (this._uri == null || !this._isDoneRecording) {\n      throw new Error('Cannot create sound when the Recording has not finished!');\n    }\n    return Sound.createAsync(\n      // $FlowFixMe: Flow can't distinguish between this literal and Asset\n      { uri: this._uri },\n      initialStatus,\n      onPlaybackStatusUpdate,\n      false\n    );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}