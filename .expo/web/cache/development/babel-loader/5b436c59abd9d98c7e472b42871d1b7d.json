{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getActiveRouteName = getActiveRouteName;\nexports.useBackButtonHandler = useBackButtonHandler;\nexports.useNavigationPersistence = useNavigationPersistence;\nexports.setRootNavigation = exports.RootNavigation = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _react = require(\"react\");\n\nvar _reactNative = require(\"react-native\");\n\nvar RootNavigation = {\n  navigate: function navigate(name) {\n    name;\n  },\n  goBack: function goBack() {},\n  resetRoot: function resetRoot(state) {},\n  getRootState: function getRootState() {\n    return {};\n  }\n};\nexports.RootNavigation = RootNavigation;\n\nvar setRootNavigation = function setRootNavigation(ref) {\n  var _loop = function _loop(method) {\n    RootNavigation[method] = function () {\n      if (ref.current) {\n        var _ref$current;\n\n        return (_ref$current = ref.current)[method].apply(_ref$current, arguments);\n      }\n    };\n  };\n\n  for (var method in RootNavigation) {\n    _loop(method);\n  }\n};\n\nexports.setRootNavigation = setRootNavigation;\n\nfunction getActiveRouteName(state) {\n  var route = state.routes[state.index];\n  if (!route.state) return route.name;\n  return getActiveRouteName(route.state);\n}\n\nfunction useBackButtonHandler(ref, canExit) {\n  var canExitRef = (0, _react.useRef)(canExit);\n  (0, _react.useEffect)(function () {\n    canExitRef.current = canExit;\n  }, [canExit]);\n  (0, _react.useEffect)(function () {\n    var onBackPress = function onBackPress() {\n      var navigation = ref.current;\n\n      if (navigation == null) {\n        return false;\n      }\n\n      var routeName = getActiveRouteName(navigation.getRootState());\n\n      if (canExitRef.current(routeName)) {\n        return false;\n      }\n\n      if (navigation.canGoBack()) {\n        navigation.goBack();\n        return true;\n      }\n\n      return false;\n    };\n\n    _reactNative.BackHandler.addEventListener(\"hardwareBackPress\", onBackPress);\n\n    return function () {\n      return _reactNative.BackHandler.removeEventListener(\"hardwareBackPress\", onBackPress);\n    };\n  }, [ref]);\n}\n\nfunction useNavigationPersistence(storage, persistenceKey) {\n  var _useState = (0, _react.useState)(),\n      _useState2 = (0, _slicedToArray2.default)(_useState, 2),\n      initialNavigationState = _useState2[0],\n      setInitialNavigationState = _useState2[1];\n\n  var _useState3 = (0, _react.useState)(true),\n      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),\n      isRestoringNavigationState = _useState4[0],\n      setIsRestoringNavigationState = _useState4[1];\n\n  var routeNameRef = (0, _react.useRef)();\n\n  var onNavigationStateChange = function onNavigationStateChange(state) {\n    var previousRouteName = routeNameRef.current;\n    var currentRouteName = getActiveRouteName(state);\n\n    if (previousRouteName !== currentRouteName) {\n      __DEV__ && console.tron.log(currentRouteName);\n    }\n\n    routeNameRef.current = currentRouteName;\n    storage.save(persistenceKey, state);\n  };\n\n  var restoreState = function restoreState() {\n    var state;\n    return _regenerator.default.async(function restoreState$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return _regenerator.default.awrap(storage.load(persistenceKey));\n\n          case 3:\n            state = _context.sent;\n            if (state) setInitialNavigationState(state);\n\n          case 5:\n            _context.prev = 5;\n            setIsRestoringNavigationState(false);\n            return _context.finish(5);\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, [[0,, 5, 8]], Promise);\n  };\n\n  (0, _react.useEffect)(function () {\n    if (isRestoringNavigationState) restoreState();\n  }, [isRestoringNavigationState]);\n  return {\n    onNavigationStateChange: onNavigationStateChange,\n    restoreState: restoreState,\n    initialNavigationState: initialNavigationState\n  };\n}","map":{"version":3,"sources":["/Users/isaacweber/code/SofamApp/app/navigation/navigation-utilities.tsx"],"names":["RootNavigation","navigate","name","goBack","resetRoot","state","getRootState","setRootNavigation","ref","method","current","getActiveRouteName","route","routes","index","useBackButtonHandler","canExit","canExitRef","onBackPress","navigation","routeName","canGoBack","BackHandler","addEventListener","removeEventListener","useNavigationPersistence","storage","persistenceKey","initialNavigationState","setInitialNavigationState","isRestoringNavigationState","setIsRestoringNavigationState","routeNameRef","onNavigationStateChange","previousRouteName","currentRouteName","__DEV__","console","tron","log","save","restoreState","load"],"mappings":"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","sourcesContent":["import React, { useState, useEffect, useRef } from \"react\"\nimport { BackHandler } from \"react-native\"\nimport { PartialState, NavigationState, NavigationContainerRef } from \"@react-navigation/native\"\n\nexport const RootNavigation = {\n  navigate(name: string) {\n    name // eslint-disable-line no-unused-expressions\n  },\n  goBack() {}, // eslint-disable-line @typescript-eslint/no-empty-function\n  resetRoot(state?: PartialState<NavigationState> | NavigationState) {}, // eslint-disable-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function\n  getRootState(): NavigationState {\n    return {} as any\n  },\n}\n\nexport const setRootNavigation = (ref: React.RefObject<NavigationContainerRef>) => {\n  for (const method in RootNavigation) {\n    RootNavigation[method] = (...args: any) => {\n      if (ref.current) {\n        return ref.current[method](...args)\n      }\n    }\n  }\n}\n\n/**\n * Gets the current screen from any navigation state.\n */\nexport function getActiveRouteName(state: NavigationState | PartialState<NavigationState>) {\n  const route = state.routes[state.index]\n\n  // Found the active route -- return the name\n  if (!route.state) return route.name\n\n  // Recursive call to deal with nested routers\n  return getActiveRouteName(route.state)\n}\n\n/**\n * Hook that handles Android back button presses and forwards those on to\n * the navigation or allows exiting the app.\n */\nexport function useBackButtonHandler(\n  ref: React.RefObject<NavigationContainerRef>,\n  canExit: (routeName: string) => boolean,\n) {\n  const canExitRef = useRef(canExit)\n\n  useEffect(() => {\n    canExitRef.current = canExit\n  }, [canExit])\n\n  useEffect(() => {\n    // We'll fire this when the back button is pressed on Android.\n    const onBackPress = () => {\n      const navigation = ref.current\n\n      if (navigation == null) {\n        return false\n      }\n\n      // grab the current route\n      const routeName = getActiveRouteName(navigation.getRootState())\n\n      // are we allowed to exit?\n      if (canExitRef.current(routeName)) {\n        // let the system know we've not handled this event\n        return false\n      }\n\n      // we can't exit, so let's turn this into a back action\n      if (navigation.canGoBack()) {\n        navigation.goBack()\n\n        return true\n      }\n\n      return false\n    }\n\n    // Subscribe when we come to life\n    BackHandler.addEventListener(\"hardwareBackPress\", onBackPress)\n\n    // Unsubscribe when we're done\n    return () => BackHandler.removeEventListener(\"hardwareBackPress\", onBackPress)\n  }, [ref])\n}\n\n/**\n * Custom hook for persisting navigation state.\n */\nexport function useNavigationPersistence(storage: any, persistenceKey: string) {\n  const [initialNavigationState, setInitialNavigationState] = useState()\n  const [isRestoringNavigationState, setIsRestoringNavigationState] = useState(true)\n\n  const routeNameRef = useRef()\n  const onNavigationStateChange = state => {\n    const previousRouteName = routeNameRef.current\n    const currentRouteName = getActiveRouteName(state)\n\n    if (previousRouteName !== currentRouteName) {\n      // track screens.\n      __DEV__ && console.tron.log(currentRouteName)\n    }\n\n    // Save the current route name for later comparision\n    routeNameRef.current = currentRouteName\n\n    // Persist state to storage\n    storage.save(persistenceKey, state)\n  }\n\n  const restoreState = async () => {\n    try {\n      const state = await storage.load(persistenceKey)\n      if (state) setInitialNavigationState(state)\n    } finally {\n      setIsRestoringNavigationState(false)\n    }\n  }\n\n  useEffect(() => {\n    if (isRestoringNavigationState) restoreState()\n  }, [isRestoringNavigationState])\n\n  return { onNavigationStateChange, restoreState, initialNavigationState }\n}\n"]},"metadata":{},"sourceType":"script"}