{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setNotificationHandler = setNotificationHandler;\nexports.NotificationTimeoutError = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _core = require(\"@unimodules/core\");\n\nvar _NotificationsHandlerModule = _interopRequireDefault(require(\"./NotificationsHandlerModule\"));\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar NotificationTimeoutError = function (_CodedError) {\n  (0, _inherits2.default)(NotificationTimeoutError, _CodedError);\n\n  var _super = _createSuper(NotificationTimeoutError);\n\n  function NotificationTimeoutError(notificationId, notification) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, NotificationTimeoutError);\n    _this = _super.call(this, 'ERR_NOTIFICATION_TIMEOUT', \"Notification handling timed out for ID \" + notificationId + \".\");\n    _this.info = {\n      id: notificationId,\n      notification: notification\n    };\n    return _this;\n  }\n\n  return NotificationTimeoutError;\n}(_core.CodedError);\n\nexports.NotificationTimeoutError = NotificationTimeoutError;\nvar notificationEmitter = new _core.EventEmitter(_NotificationsHandlerModule.default);\nvar handleNotificationEventName = 'onHandleNotification';\nvar handleNotificationTimeoutEventName = 'onHandleNotificationTimeout';\nvar handleSubscription = null;\nvar handleTimeoutSubscription = null;\n\nfunction setNotificationHandler(handler) {\n  if (handleSubscription) {\n    handleSubscription.remove();\n    handleSubscription = null;\n  }\n\n  if (handleTimeoutSubscription) {\n    handleTimeoutSubscription.remove();\n    handleTimeoutSubscription = null;\n  }\n\n  if (handler) {\n    handleSubscription = notificationEmitter.addListener(handleNotificationEventName, function _callee(_ref) {\n      var id, notification, behavior;\n      return _regenerator.default.async(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              id = _ref.id, notification = _ref.notification;\n\n              if (_NotificationsHandlerModule.default.handleNotificationAsync) {\n                _context.next = 4;\n                break;\n              }\n\n              handler.handleError == null ? void 0 : handler.handleError(id, new _core.UnavailabilityError('Notifications', 'handleNotificationAsync'));\n              return _context.abrupt(\"return\");\n\n            case 4:\n              _context.prev = 4;\n              _context.next = 7;\n              return _regenerator.default.awrap(handler.handleNotification(notification));\n\n            case 7:\n              behavior = _context.sent;\n              _context.next = 10;\n              return _regenerator.default.awrap(_NotificationsHandlerModule.default.handleNotificationAsync(id, behavior));\n\n            case 10:\n              handler.handleSuccess == null ? void 0 : handler.handleSuccess(id);\n              _context.next = 16;\n              break;\n\n            case 13:\n              _context.prev = 13;\n              _context.t0 = _context[\"catch\"](4);\n              handler.handleError == null ? void 0 : handler.handleError(id, _context.t0);\n\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, [[4, 13]], Promise);\n    });\n    handleTimeoutSubscription = notificationEmitter.addListener(handleNotificationTimeoutEventName, function (_ref2) {\n      var id = _ref2.id,\n          notification = _ref2.notification;\n      return handler.handleError == null ? void 0 : handler.handleError(id, new NotificationTimeoutError(id, notification));\n    });\n  }\n}","map":{"version":3,"sources":["../src/NotificationsHandler.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;;AAGA;;;;;;IAEa,wB;;;;;AAEX,oCAAY,cAAZ,EAAoC,YAApC,EAA8D;AAAA;;AAAA;AAC5D,8BAAM,0BAAN,8CAA4E,cAA5E;AACA,UAAK,IAAL,GAAY;AAAE,MAAA,EAAE,EAAE,cAAN;AAAsB,MAAA,YAAY,EAAZ;AAAtB,KAAZ;AAF4D;AAG7D;;;EAL2C,gB;;;AAwB9C,IAAM,mBAAmB,GAAG,IAAI,kBAAJ,CAAiB,mCAAjB,CAA5B;AAEA,IAAM,2BAA2B,GAAG,sBAApC;AACA,IAAM,kCAAkC,GAAG,6BAA3C;AAEA,IAAI,kBAAkB,GAAwB,IAA9C;AACA,IAAI,yBAAyB,GAAwB,IAArD;;AAEM,SAAU,sBAAV,CAAiC,OAAjC,EAAoE;AACxE,MAAI,kBAAJ,EAAwB;AACtB,IAAA,kBAAkB,CAAC,MAAnB;AACA,IAAA,kBAAkB,GAAG,IAArB;AACD;;AACD,MAAI,yBAAJ,EAA+B;AAC7B,IAAA,yBAAyB,CAAC,MAA1B;AACA,IAAA,yBAAyB,GAAG,IAA5B;AACD;;AAED,MAAI,OAAJ,EAAa;AACX,IAAA,kBAAkB,GAAG,mBAAmB,CAAC,WAApB,CACnB,2BADmB,EAEnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAS,cAAA,EAAT,QAAS,EAAT,EAAa,YAAb,QAAa,YAAb;;AAAA,kBACO,oCAA2B,uBADlC;AAAA;AAAA;AAAA;;AAII,cAAA,OAAO,CAAC,WAAR,oBAAA,OAAO,CAAC,WAAR,CACE,EADF,EAEE,IAAI,yBAAJ,CAAwB,eAAxB,EAAyC,yBAAzC,CAFF;AAJJ;;AAAA;AAAA;AAAA;AAAA,gDAY2B,OAAO,CAAC,kBAAR,CAA2B,YAA3B,CAZ3B;;AAAA;AAYU,cAAA,QAZV;AAAA;AAAA,gDAaU,oCAA2B,uBAA3B,CAAmD,EAAnD,EAAuD,QAAvD,CAbV;;AAAA;AAgBI,cAAA,OAAO,CAAC,aAAR,oBAAA,OAAO,CAAC,aAAR,CAAwB,EAAxB;AAhBJ;AAAA;;AAAA;AAAA;AAAA;AAoBI,cAAA,OAAO,CAAC,WAAR,oBAAA,OAAO,CAAC,WAAR,CAAsB,EAAtB;;AApBJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAFmB,CAArB;AA2BA,IAAA,yBAAyB,GAAG,mBAAmB,CAAC,WAApB,CAC1B,kCAD0B,EAE1B;AAAA,UAAG,EAAH,SAAG,EAAH;AAAA,UAAO,YAAP,SAAO,YAAP;AAAA,aACE,OAAO,CAAC,WADV,oBACE,OAAO,CAAC,WAAR,CAAsB,EAAtB,EAA0B,IAAI,wBAAJ,CAA6B,EAA7B,EAAiC,YAAjC,CAA1B,CADF;AAAA,KAF0B,CAA5B;AAKD;AACF","sourcesContent":["import { EventEmitter, Subscription, CodedError, UnavailabilityError } from '@unimodules/core';\n\nimport { Notification, NotificationBehavior } from './Notifications.types';\nimport NotificationsHandlerModule from './NotificationsHandlerModule';\n\nexport class NotificationTimeoutError extends CodedError {\n  info: { notification: Notification; id: string };\n  constructor(notificationId: string, notification: Notification) {\n    super('ERR_NOTIFICATION_TIMEOUT', `Notification handling timed out for ID ${notificationId}.`);\n    this.info = { id: notificationId, notification };\n  }\n}\n\nexport type NotificationHandlingError = NotificationTimeoutError | Error;\n\nexport interface NotificationHandler {\n  handleNotification: (notification: Notification) => Promise<NotificationBehavior>;\n  handleSuccess?: (notificationId: string) => void;\n  handleError?: (notificationId: string, error: NotificationHandlingError) => void;\n}\n\ntype HandleNotificationEvent = {\n  id: string;\n  notification: Notification;\n};\n\ntype HandleNotificationTimeoutEvent = HandleNotificationEvent;\n\n// Web uses SyntheticEventEmitter\nconst notificationEmitter = new EventEmitter(NotificationsHandlerModule);\n\nconst handleNotificationEventName = 'onHandleNotification';\nconst handleNotificationTimeoutEventName = 'onHandleNotificationTimeout';\n\nlet handleSubscription: Subscription | null = null;\nlet handleTimeoutSubscription: Subscription | null = null;\n\nexport function setNotificationHandler(handler: NotificationHandler | null): void {\n  if (handleSubscription) {\n    handleSubscription.remove();\n    handleSubscription = null;\n  }\n  if (handleTimeoutSubscription) {\n    handleTimeoutSubscription.remove();\n    handleTimeoutSubscription = null;\n  }\n\n  if (handler) {\n    handleSubscription = notificationEmitter.addListener<HandleNotificationEvent>(\n      handleNotificationEventName,\n      async ({ id, notification }) => {\n        if (!NotificationsHandlerModule.handleNotificationAsync) {\n          // TODO: Remove eslint-disable once we upgrade to a version that supports ?. notation.\n          // eslint-disable-next-line\n          handler.handleError?.(\n            id,\n            new UnavailabilityError('Notifications', 'handleNotificationAsync')\n          );\n          return;\n        }\n\n        try {\n          const behavior = await handler.handleNotification(notification);\n          await NotificationsHandlerModule.handleNotificationAsync(id, behavior);\n          // TODO: Remove eslint-disable once we upgrade to a version that supports ?. notation.\n          // eslint-disable-next-line\n          handler.handleSuccess?.(id);\n        } catch (error) {\n          // TODO: Remove eslint-disable once we upgrade to a version that supports ?. notation.\n          // eslint-disable-next-line\n          handler.handleError?.(id, error);\n        }\n      }\n    );\n\n    handleTimeoutSubscription = notificationEmitter.addListener<HandleNotificationTimeoutEvent>(\n      handleNotificationTimeoutEventName,\n      ({ id, notification }) =>\n        handler.handleError?.(id, new NotificationTimeoutError(id, notification))\n    );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}