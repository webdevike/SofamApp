{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _reactAddonsShallowCompare = _interopRequireDefault(require(\"react-addons-shallow-compare\"));\n\nvar _animations = require(\"../utils/animations\");\n\nvar _jsxFileName = \"/Users/isaacweber/code/SofamApp/node_modules/react-native-snap-carousel/src/carousel/Carousel.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar IS_ANDROID = _reactNative.Platform.OS === 'android';\nvar AnimatedFlatList = _reactNative.FlatList ? _reactNative.Animated.createAnimatedComponent(_reactNative.FlatList) : null;\n\nvar AnimatedScrollView = _reactNative.Animated.createAnimatedComponent(_reactNative.ScrollView);\n\nvar IS_RTL = _reactNative.I18nManager.isRTL;\n\nvar Carousel = function (_Component) {\n  (0, _inherits2.default)(Carousel, _Component);\n\n  var _super = _createSuper(Carousel);\n\n  function Carousel(props) {\n    var _this;\n\n    (0, _classCallCheck2.default)(this, Carousel);\n    _this = _super.call(this, props);\n    _this.state = {\n      hideCarousel: !!props.apparitionDelay,\n      interpolators: []\n    };\n\n    var initialActiveItem = _this._getFirstItem(props.firstItem);\n\n    _this._activeItem = initialActiveItem;\n    _this._onScrollActiveItem = initialActiveItem;\n    _this._previousFirstItem = initialActiveItem;\n    _this._previousItemsLength = initialActiveItem;\n    _this._mounted = false;\n    _this._positions = [];\n    _this._currentScrollOffset = 0;\n    _this._scrollEnabled = props.scrollEnabled !== false;\n    _this._getCellRendererComponent = _this._getCellRendererComponent.bind((0, _assertThisInitialized2.default)(_this));\n    _this._getItemLayout = _this._getItemLayout.bind((0, _assertThisInitialized2.default)(_this));\n    _this._getKeyExtractor = _this._getKeyExtractor.bind((0, _assertThisInitialized2.default)(_this));\n    _this._onLayout = _this._onLayout.bind((0, _assertThisInitialized2.default)(_this));\n    _this._onScroll = _this._onScroll.bind((0, _assertThisInitialized2.default)(_this));\n    _this._onMomentumScrollEnd = _this._onMomentumScrollEnd.bind((0, _assertThisInitialized2.default)(_this));\n    _this._onTouchStart = _this._onTouchStart.bind((0, _assertThisInitialized2.default)(_this));\n    _this._onTouchEnd = _this._onTouchEnd.bind((0, _assertThisInitialized2.default)(_this));\n    _this._renderItem = _this._renderItem.bind((0, _assertThisInitialized2.default)(_this));\n\n    _this._setScrollHandler(props);\n\n    _this._displayWarnings(props);\n\n    return _this;\n  }\n\n  (0, _createClass2.default)(Carousel, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          apparitionDelay = _this$props.apparitionDelay,\n          autoplay = _this$props.autoplay,\n          firstItem = _this$props.firstItem;\n      this._mounted = true;\n\n      this._initPositionsAndInterpolators();\n\n      this._initTimeout = setTimeout(function () {\n        if (!_this2._mounted) {\n          return;\n        }\n\n        var apparitionCallback = function apparitionCallback() {\n          if (apparitionDelay) {\n            _this2.setState({\n              hideCarousel: false\n            });\n          }\n\n          if (autoplay) {\n            _this2.startAutoplay();\n          }\n        };\n\n        if (_this2._needsScrollView()) {\n          var _firstItem = _this2._getFirstItem(firstItem);\n\n          _this2._snapToItem(_firstItem, false, false, true);\n        }\n\n        if (apparitionDelay) {\n          _this2._apparitionTimeout = setTimeout(function () {\n            apparitionCallback();\n          }, apparitionDelay);\n        } else {\n          apparitionCallback();\n        }\n      }, 1);\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      if (this.props.shouldOptimizeUpdates === false) {\n        return true;\n      } else {\n        return (0, _reactAddonsShallowCompare.default)(this, nextProps, nextState);\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var interpolators = this.state.interpolators;\n      var _this$props2 = this.props,\n          firstItem = _this$props2.firstItem,\n          itemHeight = _this$props2.itemHeight,\n          itemWidth = _this$props2.itemWidth,\n          scrollEnabled = _this$props2.scrollEnabled,\n          sliderHeight = _this$props2.sliderHeight,\n          sliderWidth = _this$props2.sliderWidth;\n\n      var itemsLength = this._getCustomDataLength(this.props);\n\n      if (!itemsLength) {\n        return;\n      }\n\n      var nextFirstItem = this._getFirstItem(firstItem, this.props);\n\n      var nextActiveItem = typeof this._activeItem !== 'undefined' ? this._activeItem : nextFirstItem;\n      var hasNewSliderWidth = sliderWidth && sliderWidth !== prevProps.sliderWidth;\n      var hasNewSliderHeight = sliderHeight && sliderHeight !== prevProps.sliderHeight;\n      var hasNewItemWidth = itemWidth && itemWidth !== prevProps.itemWidth;\n      var hasNewItemHeight = itemHeight && itemHeight !== prevProps.itemHeight;\n      var hasNewScrollEnabled = scrollEnabled !== prevProps.scrollEnabled;\n\n      if (nextActiveItem > itemsLength - 1) {\n        nextActiveItem = itemsLength - 1;\n      }\n\n      if (hasNewScrollEnabled) {\n        this._setScrollEnabled(scrollEnabled);\n      }\n\n      if (interpolators.length !== itemsLength || hasNewSliderWidth || hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {\n        this._activeItem = nextActiveItem;\n        this._previousItemsLength = itemsLength;\n\n        this._initPositionsAndInterpolators(this.props);\n\n        if (this._previousItemsLength > itemsLength) {\n          this._hackActiveSlideAnimation(nextActiveItem);\n        }\n\n        if (hasNewSliderWidth || hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {\n          this._snapToItem(nextActiveItem, false, false, true);\n        }\n      } else if (nextFirstItem !== this._previousFirstItem && nextFirstItem !== this._activeItem) {\n        this._activeItem = nextFirstItem;\n        this._previousFirstItem = nextFirstItem;\n\n        this._snapToItem(nextFirstItem, false, true, true);\n      }\n\n      if (this.props.onScroll !== prevProps.onScroll) {\n        this._setScrollHandler(this.props);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this._mounted = false;\n      this.stopAutoplay();\n      clearTimeout(this._initTimeout);\n      clearTimeout(this._apparitionTimeout);\n      clearTimeout(this._hackSlideAnimationTimeout);\n      clearTimeout(this._enableAutoplayTimeout);\n      clearTimeout(this._autoplayTimeout);\n      clearTimeout(this._snapNoMomentumTimeout);\n      clearTimeout(this._androidRepositioningTimeout);\n    }\n  }, {\n    key: \"_setScrollHandler\",\n    value: function _setScrollHandler(props) {\n      var scrollEventConfig = {\n        listener: this._onScroll,\n        useNativeDriver: true\n      };\n      this._scrollPos = new _reactNative.Animated.Value(0);\n      var argMapping = props.vertical ? [{\n        nativeEvent: {\n          contentOffset: {\n            y: this._scrollPos\n          }\n        }\n      }] : [{\n        nativeEvent: {\n          contentOffset: {\n            x: this._scrollPos\n          }\n        }\n      }];\n\n      if (props.onScroll && Array.isArray(props.onScroll._argMapping)) {\n        argMapping.pop();\n\n        var _props$onScroll$_argM = (0, _slicedToArray2.default)(props.onScroll._argMapping, 1),\n            argMap = _props$onScroll$_argM[0];\n\n        if (argMap && argMap.nativeEvent && argMap.nativeEvent.contentOffset) {\n          this._scrollPos = argMap.nativeEvent.contentOffset.x || argMap.nativeEvent.contentOffset.y || this._scrollPos;\n        }\n\n        argMapping.push.apply(argMapping, (0, _toConsumableArray2.default)(props.onScroll._argMapping));\n      }\n\n      this._onScrollHandler = _reactNative.Animated.event(argMapping, scrollEventConfig);\n    }\n  }, {\n    key: \"_displayWarnings\",\n    value: function _displayWarnings() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var pluginName = 'react-native-snap-carousel';\n      var removedProps = ['activeAnimationType', 'activeAnimationOptions', 'enableMomentum', 'lockScrollTimeoutDuration', 'lockScrollWhileSnapping', 'onBeforeSnapToItem', 'swipeThreshold'];\n\n      if (!props.vertical && (!props.sliderWidth || !props.itemWidth)) {\n        console.error(pluginName + \": You need to specify both 'sliderWidth' and 'itemWidth' for horizontal carousels\");\n      }\n\n      if (props.vertical && (!props.sliderHeight || !props.itemHeight)) {\n        console.error(pluginName + \": You need to specify both 'sliderHeight' and 'itemHeight' for vertical carousels\");\n      }\n\n      removedProps.forEach(function (removedProp) {\n        if (props[removedProp]) {\n          console.warn(pluginName + \": Prop \" + removedProp + \" has been removed in version 4 of the plugin\");\n        }\n      });\n    }\n  }, {\n    key: \"_needsScrollView\",\n    value: function _needsScrollView() {\n      var useScrollView = this.props.useScrollView;\n      return IS_ANDROID ? useScrollView || !AnimatedFlatList || this._shouldUseStackLayout() || this._shouldUseTinderLayout() : useScrollView || !AnimatedFlatList;\n    }\n  }, {\n    key: \"_needsRTLAdaptations\",\n    value: function _needsRTLAdaptations() {\n      var vertical = this.props.vertical;\n      return IS_RTL && IS_ANDROID && !vertical;\n    }\n  }, {\n    key: \"_enableLoop\",\n    value: function _enableLoop() {\n      var _this$props3 = this.props,\n          data = _this$props3.data,\n          enableSnap = _this$props3.enableSnap,\n          loop = _this$props3.loop;\n      return enableSnap && loop && data && data.length && data.length > 1;\n    }\n  }, {\n    key: \"_shouldAnimateSlides\",\n    value: function _shouldAnimateSlides() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var inactiveSlideOpacity = props.inactiveSlideOpacity,\n          inactiveSlideScale = props.inactiveSlideScale,\n          scrollInterpolator = props.scrollInterpolator,\n          slideInterpolatedStyle = props.slideInterpolatedStyle;\n      return inactiveSlideOpacity < 1 || inactiveSlideScale < 1 || !!scrollInterpolator || !!slideInterpolatedStyle || this._shouldUseShiftLayout() || this._shouldUseStackLayout() || this._shouldUseTinderLayout();\n    }\n  }, {\n    key: \"_shouldUseShiftLayout\",\n    value: function _shouldUseShiftLayout() {\n      var _this$props4 = this.props,\n          inactiveSlideShift = _this$props4.inactiveSlideShift,\n          layout = _this$props4.layout;\n      return layout === 'default' && inactiveSlideShift !== 0;\n    }\n  }, {\n    key: \"_shouldUseStackLayout\",\n    value: function _shouldUseStackLayout() {\n      return this.props.layout === 'stack';\n    }\n  }, {\n    key: \"_shouldUseTinderLayout\",\n    value: function _shouldUseTinderLayout() {\n      return this.props.layout === 'tinder';\n    }\n  }, {\n    key: \"_shouldRepositionScroll\",\n    value: function _shouldRepositionScroll(index) {\n      var _this$props5 = this.props,\n          data = _this$props5.data,\n          enableSnap = _this$props5.enableSnap,\n          loopClonesPerSide = _this$props5.loopClonesPerSide;\n      var dataLength = data && data.length;\n\n      if (!enableSnap || !dataLength || !this._enableLoop() || index >= loopClonesPerSide && index < dataLength + loopClonesPerSide) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_roundNumber\",\n    value: function _roundNumber(num) {\n      var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var rounder = Math.pow(10, decimals);\n      return Math.round((num + Number.EPSILON) * rounder) / rounder;\n    }\n  }, {\n    key: \"_isMultiple\",\n    value: function _isMultiple(x, y) {\n      return Math.round(Math.round(x / y) / (1 / y)) === Math.round(x);\n    }\n  }, {\n    key: \"_getCustomData\",\n    value: function _getCustomData() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var data = props.data,\n          loopClonesPerSide = props.loopClonesPerSide;\n      var dataLength = data && data.length;\n\n      if (!dataLength) {\n        return [];\n      }\n\n      if (!this._enableLoop()) {\n        return data;\n      }\n\n      var previousItems = [];\n      var nextItems = [];\n\n      if (loopClonesPerSide > dataLength) {\n        var _previousItems2, _nextItems2;\n\n        var dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n        var remainder = loopClonesPerSide % dataLength;\n\n        for (var i = 0; i < dataMultiplier; i++) {\n          var _previousItems, _nextItems;\n\n          (_previousItems = previousItems).push.apply(_previousItems, (0, _toConsumableArray2.default)(data));\n\n          (_nextItems = nextItems).push.apply(_nextItems, (0, _toConsumableArray2.default)(data));\n        }\n\n        (_previousItems2 = previousItems).unshift.apply(_previousItems2, (0, _toConsumableArray2.default)(data.slice(-remainder)));\n\n        (_nextItems2 = nextItems).push.apply(_nextItems2, (0, _toConsumableArray2.default)(data.slice(0, remainder)));\n      } else {\n        previousItems = data.slice(-loopClonesPerSide);\n        nextItems = data.slice(0, loopClonesPerSide);\n      }\n\n      return previousItems.concat(data, nextItems);\n    }\n  }, {\n    key: \"_getCustomDataLength\",\n    value: function _getCustomDataLength() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var data = props.data,\n          loopClonesPerSide = props.loopClonesPerSide;\n      var dataLength = data && data.length;\n\n      if (!dataLength) {\n        return 0;\n      }\n\n      return this._enableLoop() ? dataLength + 2 * loopClonesPerSide : dataLength;\n    }\n  }, {\n    key: \"_getCustomIndex\",\n    value: function _getCustomIndex(index) {\n      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props;\n\n      var itemsLength = this._getCustomDataLength(props);\n\n      if (!itemsLength || typeof index === 'undefined') {\n        return 0;\n      }\n\n      return this._needsRTLAdaptations() ? itemsLength - index - 1 : index;\n    }\n  }, {\n    key: \"_getDataIndex\",\n    value: function _getDataIndex(index) {\n      var _this$props6 = this.props,\n          data = _this$props6.data,\n          loopClonesPerSide = _this$props6.loopClonesPerSide;\n      var dataLength = data && data.length;\n\n      if (!this._enableLoop() || !dataLength) {\n        return index;\n      }\n\n      if (index >= dataLength + loopClonesPerSide) {\n        return loopClonesPerSide > dataLength ? (index - loopClonesPerSide) % dataLength : index - dataLength - loopClonesPerSide;\n      } else if (index < loopClonesPerSide) {\n        if (loopClonesPerSide > dataLength) {\n          var baseDataIndexes = [];\n          var dataIndexes = [];\n          var dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n          var remainder = loopClonesPerSide % dataLength;\n\n          for (var i = 0; i < dataLength; i++) {\n            baseDataIndexes.push(i);\n          }\n\n          for (var j = 0; j < dataMultiplier; j++) {\n            dataIndexes.push.apply(dataIndexes, baseDataIndexes);\n          }\n\n          dataIndexes.unshift.apply(dataIndexes, (0, _toConsumableArray2.default)(baseDataIndexes.slice(-remainder)));\n          return dataIndexes[index];\n        } else {\n          return index + dataLength - loopClonesPerSide;\n        }\n      } else {\n        return index - loopClonesPerSide;\n      }\n    }\n  }, {\n    key: \"_getPositionIndex\",\n    value: function _getPositionIndex(index) {\n      var _this$props7 = this.props,\n          loop = _this$props7.loop,\n          loopClonesPerSide = _this$props7.loopClonesPerSide;\n      return loop ? index + loopClonesPerSide : index;\n    }\n  }, {\n    key: \"_getSnapOffsets\",\n    value: function _getSnapOffsets() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n\n      var offset = this._getItemMainDimension();\n\n      return (0, _toConsumableArray2.default)(Array(this._getCustomDataLength(props))).map(function (_, i) {\n        return i * offset;\n      });\n    }\n  }, {\n    key: \"_getFirstItem\",\n    value: function _getFirstItem(index) {\n      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props;\n      var loopClonesPerSide = props.loopClonesPerSide;\n\n      var itemsLength = this._getCustomDataLength(props);\n\n      if (!itemsLength || index > itemsLength - 1 || index < 0) {\n        return 0;\n      }\n\n      return this._enableLoop() ? index + loopClonesPerSide : index;\n    }\n  }, {\n    key: \"_getWrappedRef\",\n    value: function _getWrappedRef() {\n      if (this._carouselRef && (this._needsScrollView() && this._carouselRef.scrollTo || !this._needsScrollView() && this._carouselRef.scrollToOffset)) {\n        return this._carouselRef;\n      }\n\n      return this._carouselRef && this._carouselRef.getNode && this._carouselRef.getNode();\n    }\n  }, {\n    key: \"_getScrollEnabled\",\n    value: function _getScrollEnabled() {\n      return this._scrollEnabled;\n    }\n  }, {\n    key: \"_setScrollEnabled\",\n    value: function _setScrollEnabled() {\n      var scrollEnabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      var wrappedRef = this._getWrappedRef();\n\n      if (!wrappedRef || !wrappedRef.setNativeProps) {\n        return;\n      }\n\n      wrappedRef.setNativeProps({\n        scrollEnabled: scrollEnabled\n      });\n      this._scrollEnabled = scrollEnabled;\n    }\n  }, {\n    key: \"_getItemMainDimension\",\n    value: function _getItemMainDimension() {\n      var _this$props8 = this.props,\n          itemWidth = _this$props8.itemWidth,\n          itemHeight = _this$props8.itemHeight,\n          vertical = _this$props8.vertical;\n      return vertical ? itemHeight : itemWidth;\n    }\n  }, {\n    key: \"_getItemScrollOffset\",\n    value: function _getItemScrollOffset(index) {\n      return this._positions && this._positions[index] && this._positions[index].start;\n    }\n  }, {\n    key: \"_getItemLayout\",\n    value: function _getItemLayout(_, index) {\n      var itemMainDimension = this._getItemMainDimension();\n\n      return {\n        index: index,\n        length: itemMainDimension,\n        offset: itemMainDimension * index\n      };\n    }\n  }, {\n    key: \"_getCellRendererComponent\",\n    value: function _getCellRendererComponent(_ref) {\n      var children = _ref.children,\n          index = _ref.index,\n          style = _ref.style,\n          props = (0, _objectWithoutProperties2.default)(_ref, [\"children\", \"index\", \"style\"]);\n      var cellStyle = [style, !IS_ANDROID ? {\n        zIndex: this._getCustomDataLength() - index\n      } : {}];\n      return _react.default.createElement(_reactNative.View, (0, _extends2.default)({\n        style: cellStyle,\n        index: index\n      }, props, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 578,\n          columnNumber: 13\n        }\n      }), children);\n    }\n  }, {\n    key: \"_getKeyExtractor\",\n    value: function _getKeyExtractor(_, index) {\n      return this._needsScrollView() ? \"scrollview-item-\" + index : \"flatlist-item-\" + index;\n    }\n  }, {\n    key: \"_getScrollOffset\",\n    value: function _getScrollOffset(event) {\n      var vertical = this.props.vertical;\n      return event && event.nativeEvent && event.nativeEvent.contentOffset && event.nativeEvent.contentOffset[vertical ? 'y' : 'x'] || 0;\n    }\n  }, {\n    key: \"_getContainerInnerMargin\",\n    value: function _getContainerInnerMargin() {\n      var opposite = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var _this$props9 = this.props,\n          sliderWidth = _this$props9.sliderWidth,\n          sliderHeight = _this$props9.sliderHeight,\n          itemWidth = _this$props9.itemWidth,\n          itemHeight = _this$props9.itemHeight,\n          vertical = _this$props9.vertical,\n          activeSlideAlignment = _this$props9.activeSlideAlignment;\n\n      if (activeSlideAlignment === 'start' && !opposite || activeSlideAlignment === 'end' && opposite) {\n        return 0;\n      } else if (activeSlideAlignment === 'end' && !opposite || activeSlideAlignment === 'start' && opposite) {\n        return vertical ? sliderHeight - itemHeight : sliderWidth - itemWidth;\n      } else {\n        return vertical ? (sliderHeight - itemHeight) / 2 : (sliderWidth - itemWidth) / 2;\n      }\n    }\n  }, {\n    key: \"_getActiveSlideOffset\",\n    value: function _getActiveSlideOffset() {\n      var activeSlideOffset = this.props.activeSlideOffset;\n\n      var itemMainDimension = this._getItemMainDimension();\n\n      var minOffset = 10;\n      return itemMainDimension / 2 - activeSlideOffset >= minOffset ? activeSlideOffset : minOffset;\n    }\n  }, {\n    key: \"_getActiveItem\",\n    value: function _getActiveItem(offset) {\n      var itemMainDimension = this._getItemMainDimension();\n\n      var center = offset + itemMainDimension / 2;\n\n      var activeSlideOffset = this._getActiveSlideOffset();\n\n      var lastIndex = this._positions.length - 1;\n      var itemIndex;\n\n      if (offset <= 0) {\n        return 0;\n      }\n\n      if (this._positions[lastIndex] && offset >= this._positions[lastIndex].start) {\n        return lastIndex;\n      }\n\n      for (var i = 0; i < this._positions.length; i++) {\n        var _this$_positions$i = this._positions[i],\n            start = _this$_positions$i.start,\n            end = _this$_positions$i.end;\n\n        if (center + activeSlideOffset >= start && center - activeSlideOffset <= end) {\n          itemIndex = i;\n          break;\n        }\n      }\n\n      return itemIndex || 0;\n    }\n  }, {\n    key: \"_getSlideInterpolatedStyle\",\n    value: function _getSlideInterpolatedStyle(index, animatedValue) {\n      var _this$props10 = this.props,\n          layoutCardOffset = _this$props10.layoutCardOffset,\n          slideInterpolatedStyle = _this$props10.slideInterpolatedStyle;\n\n      if (slideInterpolatedStyle) {\n        return slideInterpolatedStyle(index, animatedValue, this.props);\n      } else if (this._shouldUseTinderLayout()) {\n        return (0, _animations.tinderAnimatedStyles)(index, animatedValue, this.props, layoutCardOffset);\n      } else if (this._shouldUseStackLayout()) {\n        return (0, _animations.stackAnimatedStyles)(index, animatedValue, this.props, layoutCardOffset);\n      } else if (this._shouldUseShiftLayout()) {\n        return (0, _animations.shiftAnimatedStyles)(index, animatedValue, this.props);\n      } else {\n        return (0, _animations.defaultAnimatedStyles)(index, animatedValue, this.props);\n      }\n    }\n  }, {\n    key: \"_initPositionsAndInterpolators\",\n    value: function _initPositionsAndInterpolators() {\n      var _this3 = this;\n\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var data = props.data,\n          scrollInterpolator = props.scrollInterpolator;\n\n      var itemMainDimension = this._getItemMainDimension();\n\n      if (!data || !data.length) {\n        return;\n      }\n\n      var interpolators = [];\n      this._positions = [];\n\n      this._getCustomData(props).forEach(function (itemData, index) {\n        var _index = _this3._getCustomIndex(index, props);\n\n        var animatedValue;\n        _this3._positions[index] = {\n          start: index * itemMainDimension,\n          end: index * itemMainDimension + itemMainDimension\n        };\n\n        if (!_this3._shouldAnimateSlides(props)) {\n          animatedValue = new _reactNative.Animated.Value(1);\n        } else {\n          var interpolator;\n\n          if (scrollInterpolator) {\n            interpolator = scrollInterpolator(_index, props);\n          } else if (_this3._shouldUseStackLayout()) {\n            interpolator = (0, _animations.stackScrollInterpolator)(_index, props);\n          } else if (_this3._shouldUseTinderLayout()) {\n            interpolator = (0, _animations.tinderScrollInterpolator)(_index, props);\n          }\n\n          if (!interpolator || !interpolator.inputRange || !interpolator.outputRange) {\n            interpolator = (0, _animations.defaultScrollInterpolator)(_index, props);\n          }\n\n          animatedValue = _this3._scrollPos.interpolate(_objectSpread(_objectSpread({}, interpolator), {}, {\n            extrapolate: 'clamp'\n          }));\n        }\n\n        interpolators.push(animatedValue);\n      });\n\n      this.setState({\n        interpolators: interpolators\n      });\n    }\n  }, {\n    key: \"_hackActiveSlideAnimation\",\n    value: function _hackActiveSlideAnimation(index) {\n      var _this4 = this;\n\n      var scrollValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      var offset = this._getItemScrollOffset(index);\n\n      if (!this._mounted || !this._carouselRef || typeof offset === 'undefined') {\n        return;\n      }\n\n      var multiplier = this._currentScrollOffset === 0 ? 1 : -1;\n      var scrollDelta = scrollValue * multiplier;\n\n      this._scrollTo({\n        offset: offset + scrollDelta,\n        animated: false\n      });\n\n      clearTimeout(this._hackSlideAnimationTimeout);\n      this._hackSlideAnimationTimeout = setTimeout(function () {\n        _this4._scrollTo({\n          offset: offset,\n          animated: false\n        });\n      }, 1);\n    }\n  }, {\n    key: \"_repositionScroll\",\n    value: function _repositionScroll(index) {\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var _this$props11 = this.props,\n          data = _this$props11.data,\n          loopClonesPerSide = _this$props11.loopClonesPerSide;\n      var dataLength = data && data.length;\n\n      if (typeof index === 'undefined' || !this._shouldRepositionScroll(index)) {\n        return;\n      }\n\n      var repositionTo = index;\n\n      if (index >= dataLength + loopClonesPerSide) {\n        repositionTo = index - dataLength;\n      } else if (index < loopClonesPerSide) {\n        repositionTo = index + dataLength;\n      }\n\n      this._snapToItem(repositionTo, animated, false);\n    }\n  }, {\n    key: \"_scrollTo\",\n    value: function _scrollTo(_ref2) {\n      var offset = _ref2.offset,\n          index = _ref2.index,\n          _ref2$animated = _ref2.animated,\n          animated = _ref2$animated === void 0 ? true : _ref2$animated;\n      var vertical = this.props.vertical;\n\n      var wrappedRef = this._getWrappedRef();\n\n      if (!this._mounted || !wrappedRef || typeof offset === 'undefined' && typeof index === 'undefined') {\n        return;\n      }\n\n      var scrollToOffset;\n\n      if (typeof index !== 'undefined') {\n        scrollToOffset = this._getItemScrollOffset(index);\n      } else {\n        scrollToOffset = offset;\n      }\n\n      if (typeof scrollToOffset === 'undefined') {\n        return;\n      }\n\n      var options = this._needsScrollView() ? {\n        x: vertical ? 0 : offset,\n        y: vertical ? offset : 0,\n        animated: animated\n      } : {\n        offset: offset,\n        animated: animated\n      };\n\n      if (this._needsScrollView()) {\n        wrappedRef.scrollTo(options);\n      } else {\n        wrappedRef.scrollToOffset(options);\n      }\n    }\n  }, {\n    key: \"_onTouchStart\",\n    value: function _onTouchStart() {\n      var onTouchStart = this.props.onTouchStart;\n\n      if (this._getScrollEnabled() !== false && this._autoplaying) {\n        this.pauseAutoPlay();\n      }\n\n      onTouchStart && onTouchStart();\n    }\n  }, {\n    key: \"_onTouchEnd\",\n    value: function _onTouchEnd() {\n      var onTouchEnd = this.props.onTouchEnd;\n\n      if (this._getScrollEnabled() !== false && this._autoplay && !this._autoplaying) {\n        this.startAutoplay();\n      }\n\n      onTouchEnd && onTouchEnd();\n    }\n  }, {\n    key: \"_onScroll\",\n    value: function _onScroll(event) {\n      var _this$props12 = this.props,\n          onScroll = _this$props12.onScroll,\n          onScrollIndexChanged = _this$props12.onScrollIndexChanged;\n      var scrollOffset = event ? this._getScrollOffset(event) : this._currentScrollOffset;\n\n      var nextActiveItem = this._getActiveItem(scrollOffset);\n\n      this._currentScrollOffset = scrollOffset;\n\n      if (nextActiveItem !== this._onScrollActiveItem) {\n        this._onScrollActiveItem = nextActiveItem;\n        onScrollIndexChanged && onScrollIndexChanged(this._getDataIndex(nextActiveItem));\n      }\n\n      if (typeof onScroll === 'function' && event) {\n        onScroll(event);\n      }\n    }\n  }, {\n    key: \"_onMomentumScrollEnd\",\n    value: function _onMomentumScrollEnd(event) {\n      var _this5 = this;\n\n      var _this$props13 = this.props,\n          autoplayDelay = _this$props13.autoplayDelay,\n          itemWidth = _this$props13.itemWidth,\n          onMomentumScrollEnd = _this$props13.onMomentumScrollEnd,\n          onSnapToItem = _this$props13.onSnapToItem;\n      var scrollOffset = event ? this._getScrollOffset(event) : this._currentScrollOffset;\n\n      var nextActiveItem = this._getActiveItem(scrollOffset);\n\n      var hasSnapped = this._isMultiple(scrollOffset, itemWidth);\n\n      if (nextActiveItem !== this._activeItem) {\n        this._activeItem = nextActiveItem;\n        onSnapToItem && onSnapToItem(this._getDataIndex(nextActiveItem));\n\n        if (hasSnapped) {\n          this._repositionScroll(nextActiveItem);\n        }\n      }\n\n      onMomentumScrollEnd && onMomentumScrollEnd(event);\n\n      if (IS_ANDROID && this._autoplay && !this._autoplaying) {\n        clearTimeout(this._enableAutoplayTimeout);\n        this._enableAutoplayTimeout = setTimeout(function () {\n          _this5.startAutoplay();\n        }, autoplayDelay);\n      }\n    }\n  }, {\n    key: \"_onLayout\",\n    value: function _onLayout(event) {\n      var onLayout = this.props.onLayout;\n\n      if (this._onLayoutInitDone) {\n        this._initPositionsAndInterpolators();\n\n        this._snapToItem(this._activeItem, false, false, true);\n      } else {\n        this._onLayoutInitDone = true;\n      }\n\n      onLayout && onLayout(event);\n    }\n  }, {\n    key: \"_snapToItem\",\n    value: function _snapToItem(index) {\n      var _this6 = this;\n\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var fireCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var forceScrollTo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var onSnapToItem = this.props.onSnapToItem;\n\n      var itemsLength = this._getCustomDataLength();\n\n      var wrappedRef = this._getWrappedRef();\n\n      if (!itemsLength || !wrappedRef) {\n        return;\n      }\n\n      if (!index || index < 0) {\n        index = 0;\n      } else if (itemsLength > 0 && index >= itemsLength) {\n        index = itemsLength - 1;\n      }\n\n      if (index === this._activeItem && !forceScrollTo) {\n        return;\n      }\n\n      var offset = this._getItemScrollOffset(index);\n\n      if (offset === undefined) {\n        return;\n      }\n\n      this._scrollTo({\n        offset: offset,\n        animated: animated\n      });\n\n      var requiresManualTrigger = !animated || IS_ANDROID;\n\n      if (requiresManualTrigger) {\n        this._activeItem = index;\n\n        if (fireCallback) {\n          onSnapToItem && onSnapToItem(this._getDataIndex(index));\n        }\n\n        if (IS_ANDROID && this._shouldRepositionScroll(index)) {\n          if (animated) {\n            this._androidRepositioningTimeout = setTimeout(function () {\n              _this6._repositionScroll(index, true);\n            }, 400);\n          } else {\n            this._repositionScroll(index);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"startAutoplay\",\n    value: function startAutoplay() {\n      var _this7 = this;\n\n      var _this$props14 = this.props,\n          autoplayInterval = _this$props14.autoplayInterval,\n          autoplayDelay = _this$props14.autoplayDelay;\n      this._autoplay = true;\n\n      if (this._autoplaying) {\n        return;\n      }\n\n      clearTimeout(this._autoplayTimeout);\n      this._autoplayTimeout = setTimeout(function () {\n        _this7._autoplaying = true;\n        _this7._autoplayInterval = setInterval(function () {\n          if (_this7._autoplaying) {\n            _this7.snapToNext();\n          }\n        }, autoplayInterval);\n      }, autoplayDelay);\n    }\n  }, {\n    key: \"pauseAutoPlay\",\n    value: function pauseAutoPlay() {\n      this._autoplaying = false;\n      clearTimeout(this._autoplayTimeout);\n      clearTimeout(this._enableAutoplayTimeout);\n      clearInterval(this._autoplayInterval);\n    }\n  }, {\n    key: \"stopAutoplay\",\n    value: function stopAutoplay() {\n      this._autoplay = false;\n      this.pauseAutoPlay();\n    }\n  }, {\n    key: \"snapToItem\",\n    value: function snapToItem(index) {\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var fireCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      if (!index || index < 0) {\n        index = 0;\n      }\n\n      var positionIndex = this._getPositionIndex(index);\n\n      if (positionIndex === this._activeItem) {\n        return;\n      }\n\n      this._snapToItem(positionIndex, animated, fireCallback);\n    }\n  }, {\n    key: \"snapToNext\",\n    value: function snapToNext() {\n      var animated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var fireCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var itemsLength = this._getCustomDataLength();\n\n      var newIndex = this._activeItem + 1;\n\n      if (newIndex > itemsLength - 1) {\n        newIndex = 0;\n      }\n\n      this._snapToItem(newIndex, animated, fireCallback);\n    }\n  }, {\n    key: \"snapToPrev\",\n    value: function snapToPrev() {\n      var animated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var fireCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var itemsLength = this._getCustomDataLength();\n\n      var newIndex = this._activeItem - 1;\n\n      if (newIndex < 0) {\n        newIndex = itemsLength - 1;\n      }\n\n      this._snapToItem(newIndex, animated, fireCallback);\n    }\n  }, {\n    key: \"triggerRenderingHack\",\n    value: function triggerRenderingHack() {\n      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      this._hackActiveSlideAnimation(this._activeItem, offset);\n    }\n  }, {\n    key: \"_renderItem\",\n    value: function _renderItem(_ref3) {\n      var item = _ref3.item,\n          index = _ref3.index;\n      var interpolators = this.state.interpolators;\n      var _this$props15 = this.props,\n          hasParallaxImages = _this$props15.hasParallaxImages,\n          itemWidth = _this$props15.itemWidth,\n          itemHeight = _this$props15.itemHeight,\n          keyExtractor = _this$props15.keyExtractor,\n          renderItem = _this$props15.renderItem,\n          sliderHeight = _this$props15.sliderHeight,\n          sliderWidth = _this$props15.sliderWidth,\n          slideStyle = _this$props15.slideStyle,\n          vertical = _this$props15.vertical;\n      var animatedValue = interpolators && interpolators[index];\n\n      if (typeof animatedValue === 'undefined') {\n        return null;\n      }\n\n      var animate = this._shouldAnimateSlides();\n\n      var Component = animate ? _reactNative.Animated.View : _reactNative.View;\n      var animatedStyle = animate ? this._getSlideInterpolatedStyle(index, animatedValue) : {};\n\n      var dataIndex = this._getDataIndex(index);\n\n      var parallaxProps = hasParallaxImages ? {\n        scrollPosition: this._scrollPos,\n        carouselRef: this._carouselRef,\n        vertical: vertical,\n        sliderWidth: sliderWidth,\n        sliderHeight: sliderHeight,\n        itemWidth: itemWidth,\n        itemHeight: itemHeight\n      } : undefined;\n      var mainDimension = vertical ? {\n        height: itemHeight\n      } : {\n        width: itemWidth\n      };\n      var specificProps = this._needsScrollView() ? {\n        key: keyExtractor ? keyExtractor(item, index) : this._getKeyExtractor(item, index)\n      } : {};\n      return _react.default.createElement(Component, (0, _extends2.default)({\n        style: [mainDimension, slideStyle, animatedStyle],\n        pointerEvents: 'box-none'\n      }, specificProps, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1018,\n          columnNumber: 13\n        }\n      }), renderItem({\n        item: item,\n        index: index,\n        dataIndex: dataIndex\n      }, parallaxProps));\n    }\n  }, {\n    key: \"_getComponentOverridableProps\",\n    value: function _getComponentOverridableProps() {\n      var hideCarousel = this.state.hideCarousel;\n      var _this$props16 = this.props,\n          itemWidth = _this$props16.itemWidth,\n          itemHeight = _this$props16.itemHeight,\n          loopClonesPerSide = _this$props16.loopClonesPerSide,\n          sliderWidth = _this$props16.sliderWidth,\n          sliderHeight = _this$props16.sliderHeight,\n          vertical = _this$props16.vertical;\n      var visibleItems = Math.ceil(vertical ? sliderHeight / itemHeight : sliderWidth / itemWidth) + 1;\n      var initialNumPerSide = this._enableLoop() ? loopClonesPerSide : 2;\n      var initialNumToRender = visibleItems + initialNumPerSide * 2;\n      var maxToRenderPerBatch = initialNumToRender + initialNumPerSide * 2;\n      var windowSize = maxToRenderPerBatch;\n      var specificProps = !this._needsScrollView() ? {\n        initialNumToRender: initialNumToRender,\n        maxToRenderPerBatch: maxToRenderPerBatch,\n        windowSize: windowSize\n      } : {};\n      return _objectSpread(_objectSpread({}, specificProps), {}, {\n        automaticallyAdjustContentInsets: false,\n        decelerationRate: 'fast',\n        directionalLockEnabled: true,\n        disableScrollViewPanResponder: false,\n        inverted: this._needsRTLAdaptations(),\n        overScrollMode: 'never',\n        pinchGestureEnabled: false,\n        pointerEvents: hideCarousel ? 'none' : 'auto',\n        scrollsToTop: false,\n        showsHorizontalScrollIndicator: false,\n        showsVerticalScrollIndicator: false\n      });\n    }\n  }, {\n    key: \"_getComponentStaticProps\",\n    value: function _getComponentStaticProps() {\n      var _this8 = this;\n\n      var hideCarousel = this.state.hideCarousel;\n      var _this$props17 = this.props,\n          activeSlideAlignment = _this$props17.activeSlideAlignment,\n          CellRendererComponent = _this$props17.CellRendererComponent,\n          containerCustomStyle = _this$props17.containerCustomStyle,\n          contentContainerCustomStyle = _this$props17.contentContainerCustomStyle,\n          firstItem = _this$props17.firstItem,\n          getItemLayout = _this$props17.getItemLayout,\n          keyExtractor = _this$props17.keyExtractor,\n          sliderWidth = _this$props17.sliderWidth,\n          sliderHeight = _this$props17.sliderHeight,\n          style = _this$props17.style,\n          useExperimentalSnap = _this$props17.useExperimentalSnap,\n          vertical = _this$props17.vertical;\n      var containerStyle = [containerCustomStyle || style || {}, hideCarousel ? {\n        opacity: 0\n      } : {}, vertical ? {\n        height: sliderHeight,\n        flexDirection: 'column'\n      } : {\n        width: sliderWidth,\n        flexDirection: this._needsRTLAdaptations() ? 'row-reverse' : 'row'\n      }];\n      var innerMarginStyle = vertical ? {\n        paddingTop: this._getContainerInnerMargin(),\n        paddingBottom: this._getContainerInnerMargin(true)\n      } : {\n        paddingLeft: this._getContainerInnerMargin(),\n        paddingRight: this._getContainerInnerMargin(true)\n      };\n      var contentContainerStyle = [!useExperimentalSnap ? innerMarginStyle : {}, contentContainerCustomStyle || {}];\n      var snapProps = useExperimentalSnap ? {\n        snapToAlignment: activeSlideAlignment,\n        snapToInterval: this._getItemMainDimension()\n      } : {\n        snapToOffsets: this._getSnapOffsets()\n      };\n      var specificProps = !this._needsScrollView() ? {\n        CellRendererComponent: CellRendererComponent || this._getCellRendererComponent,\n        getItemLayout: getItemLayout || this._getItemLayout,\n        initialScrollIndex: this._getFirstItem(firstItem),\n        keyExtractor: keyExtractor || this._getKeyExtractor,\n        numColumns: 1,\n        renderItem: this._renderItem\n      } : {};\n      return _objectSpread(_objectSpread(_objectSpread({}, specificProps), snapProps), {}, {\n        ref: function ref(c) {\n          _this8._carouselRef = c;\n        },\n        contentContainerStyle: contentContainerStyle,\n        data: this._getCustomData(),\n        horizontal: !vertical,\n        scrollEventThrottle: 1,\n        style: containerStyle,\n        onLayout: this._onLayout,\n        onMomentumScrollEnd: this._onMomentumScrollEnd,\n        onScroll: this._onScrollHandler,\n        onTouchStart: this._onTouchStart,\n        onTouchEnd: this._onTouchEnd\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this9 = this;\n\n      var _this$props18 = this.props,\n          data = _this$props18.data,\n          renderItem = _this$props18.renderItem,\n          useScrollView = _this$props18.useScrollView;\n\n      if (!data || !renderItem) {\n        return null;\n      }\n\n      var props = _objectSpread(_objectSpread(_objectSpread({}, this._getComponentOverridableProps()), this.props), this._getComponentStaticProps());\n\n      var ScrollViewComponent = typeof useScrollView === 'function' ? useScrollView : AnimatedScrollView;\n      return this._needsScrollView() ? _react.default.createElement(ScrollViewComponent, (0, _extends2.default)({}, props, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1150,\n          columnNumber: 13\n        }\n      }), this._getCustomData().map(function (item, index) {\n        return _this9._renderItem({\n          item: item,\n          index: index\n        });\n      })) : _react.default.createElement(AnimatedFlatList, (0, _extends2.default)({}, props, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1158,\n          columnNumber: 13\n        }\n      }));\n    }\n  }, {\n    key: \"realIndex\",\n    get: function get() {\n      return this._activeItem;\n    }\n  }, {\n    key: \"currentIndex\",\n    get: function get() {\n      return this._getDataIndex(this._activeItem);\n    }\n  }, {\n    key: \"currentScrollPosition\",\n    get: function get() {\n      return this._currentScrollOffset;\n    }\n  }]);\n  return Carousel;\n}(_react.Component);\n\nexports.default = Carousel;\nCarousel.propTypes = {\n  data: _propTypes.default.array.isRequired,\n  renderItem: _propTypes.default.func.isRequired,\n  itemWidth: _propTypes.default.number,\n  itemHeight: _propTypes.default.number,\n  sliderWidth: _propTypes.default.number,\n  sliderHeight: _propTypes.default.number,\n  activeSlideAlignment: _propTypes.default.oneOf(['center', 'end', 'start']),\n  activeSlideOffset: _propTypes.default.number,\n  apparitionDelay: _propTypes.default.number,\n  autoplay: _propTypes.default.bool,\n  autoplayDelay: _propTypes.default.number,\n  autoplayInterval: _propTypes.default.number,\n  callbackOffsetMargin: _propTypes.default.number,\n  containerCustomStyle: _reactNative.ViewPropTypes ? _reactNative.ViewPropTypes.style : _reactNative.View.propTypes.style,\n  contentContainerCustomStyle: _reactNative.ViewPropTypes ? _reactNative.ViewPropTypes.style : _reactNative.View.propTypes.style,\n  enableSnap: _propTypes.default.bool,\n  firstItem: _propTypes.default.number,\n  hasParallaxImages: _propTypes.default.bool,\n  inactiveSlideOpacity: _propTypes.default.number,\n  inactiveSlideScale: _propTypes.default.number,\n  inactiveSlideShift: _propTypes.default.number,\n  layout: _propTypes.default.oneOf(['default', 'stack', 'tinder']),\n  layoutCardOffset: _propTypes.default.number,\n  loop: _propTypes.default.bool,\n  loopClonesPerSide: _propTypes.default.number,\n  scrollEnabled: _propTypes.default.bool,\n  scrollInterpolator: _propTypes.default.func,\n  slideInterpolatedStyle: _propTypes.default.func,\n  slideStyle: _reactNative.ViewPropTypes ? _reactNative.ViewPropTypes.style : _reactNative.View.propTypes.style,\n  shouldOptimizeUpdates: _propTypes.default.bool,\n  useExperimentalSnap: _propTypes.default.bool,\n  useScrollView: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.func]),\n  vertical: _propTypes.default.bool,\n  onScrollIndexChanged: _propTypes.default.func,\n  onSnapToItem: _propTypes.default.func\n};\nCarousel.defaultProps = {\n  activeSlideAlignment: 'center',\n  activeSlideOffset: 20,\n  apparitionDelay: 0,\n  autoplay: false,\n  autoplayDelay: 1000,\n  autoplayInterval: 3000,\n  callbackOffsetMargin: 5,\n  containerCustomStyle: {},\n  contentContainerCustomStyle: {},\n  enableSnap: true,\n  firstItem: 0,\n  hasParallaxImages: false,\n  inactiveSlideOpacity: 0.7,\n  inactiveSlideScale: 0.9,\n  inactiveSlideShift: 0,\n  layout: 'default',\n  loop: false,\n  loopClonesPerSide: 3,\n  scrollEnabled: true,\n  slideStyle: {},\n  shouldOptimizeUpdates: true,\n  useExperimentalSnap: false,\n  useScrollView: !AnimatedFlatList,\n  vertical: false\n};","map":{"version":3,"sources":["/Users/isaacweber/code/SofamApp/node_modules/react-native-snap-carousel/src/carousel/Carousel.js"],"names":["IS_ANDROID","Platform","OS","AnimatedFlatList","FlatList","Animated","createAnimatedComponent","AnimatedScrollView","ScrollView","IS_RTL","I18nManager","isRTL","Carousel","props","state","hideCarousel","apparitionDelay","interpolators","initialActiveItem","_getFirstItem","firstItem","_activeItem","_onScrollActiveItem","_previousFirstItem","_previousItemsLength","_mounted","_positions","_currentScrollOffset","_scrollEnabled","scrollEnabled","_getCellRendererComponent","bind","_getItemLayout","_getKeyExtractor","_onLayout","_onScroll","_onMomentumScrollEnd","_onTouchStart","_onTouchEnd","_renderItem","_setScrollHandler","_displayWarnings","autoplay","_initPositionsAndInterpolators","_initTimeout","setTimeout","apparitionCallback","setState","startAutoplay","_needsScrollView","_firstItem","_snapToItem","_apparitionTimeout","nextProps","nextState","shouldOptimizeUpdates","prevProps","itemHeight","itemWidth","sliderHeight","sliderWidth","itemsLength","_getCustomDataLength","nextFirstItem","nextActiveItem","hasNewSliderWidth","hasNewSliderHeight","hasNewItemWidth","hasNewItemHeight","hasNewScrollEnabled","_setScrollEnabled","length","_hackActiveSlideAnimation","onScroll","stopAutoplay","clearTimeout","_hackSlideAnimationTimeout","_enableAutoplayTimeout","_autoplayTimeout","_snapNoMomentumTimeout","_androidRepositioningTimeout","scrollEventConfig","listener","useNativeDriver","_scrollPos","Value","argMapping","vertical","nativeEvent","contentOffset","y","x","Array","isArray","_argMapping","pop","argMap","push","_onScrollHandler","event","pluginName","removedProps","console","error","forEach","removedProp","warn","useScrollView","_shouldUseStackLayout","_shouldUseTinderLayout","data","enableSnap","loop","inactiveSlideOpacity","inactiveSlideScale","scrollInterpolator","slideInterpolatedStyle","_shouldUseShiftLayout","inactiveSlideShift","layout","index","loopClonesPerSide","dataLength","_enableLoop","num","decimals","rounder","Math","pow","round","Number","EPSILON","previousItems","nextItems","dataMultiplier","floor","remainder","i","unshift","slice","concat","_needsRTLAdaptations","baseDataIndexes","dataIndexes","j","offset","_getItemMainDimension","map","_","_carouselRef","scrollTo","scrollToOffset","getNode","wrappedRef","_getWrappedRef","setNativeProps","start","itemMainDimension","children","style","cellStyle","zIndex","opposite","activeSlideAlignment","activeSlideOffset","minOffset","center","_getActiveSlideOffset","lastIndex","itemIndex","end","animatedValue","layoutCardOffset","_getCustomData","itemData","_index","_getCustomIndex","_shouldAnimateSlides","interpolator","inputRange","outputRange","interpolate","extrapolate","scrollValue","_getItemScrollOffset","multiplier","scrollDelta","_scrollTo","animated","_shouldRepositionScroll","repositionTo","options","onTouchStart","_getScrollEnabled","_autoplaying","pauseAutoPlay","onTouchEnd","_autoplay","onScrollIndexChanged","scrollOffset","_getScrollOffset","_getActiveItem","_getDataIndex","autoplayDelay","onMomentumScrollEnd","onSnapToItem","hasSnapped","_isMultiple","_repositionScroll","onLayout","_onLayoutInitDone","fireCallback","forceScrollTo","undefined","requiresManualTrigger","autoplayInterval","_autoplayInterval","setInterval","snapToNext","clearInterval","positionIndex","_getPositionIndex","newIndex","item","hasParallaxImages","keyExtractor","renderItem","slideStyle","animate","Component","View","animatedStyle","_getSlideInterpolatedStyle","dataIndex","parallaxProps","scrollPosition","carouselRef","mainDimension","height","width","specificProps","key","visibleItems","ceil","initialNumPerSide","initialNumToRender","maxToRenderPerBatch","windowSize","automaticallyAdjustContentInsets","decelerationRate","directionalLockEnabled","disableScrollViewPanResponder","inverted","overScrollMode","pinchGestureEnabled","pointerEvents","scrollsToTop","showsHorizontalScrollIndicator","showsVerticalScrollIndicator","CellRendererComponent","containerCustomStyle","contentContainerCustomStyle","getItemLayout","useExperimentalSnap","containerStyle","opacity","flexDirection","innerMarginStyle","paddingTop","_getContainerInnerMargin","paddingBottom","paddingLeft","paddingRight","contentContainerStyle","snapProps","snapToAlignment","snapToInterval","snapToOffsets","_getSnapOffsets","initialScrollIndex","numColumns","ref","c","horizontal","scrollEventThrottle","_getComponentOverridableProps","_getComponentStaticProps","ScrollViewComponent","propTypes","PropTypes","array","isRequired","func","number","oneOf","bool","callbackOffsetMargin","ViewPropTypes","oneOfType","defaultProps"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport { Animated, FlatList, I18nManager, Platform, ScrollView, View, ViewPropTypes } from 'react-native';\nimport PropTypes from 'prop-types';\nimport shallowCompare from 'react-addons-shallow-compare';\nimport {\n    defaultScrollInterpolator, stackScrollInterpolator, tinderScrollInterpolator, defaultAnimatedStyles,\n    shiftAnimatedStyles, stackAnimatedStyles, tinderAnimatedStyles\n} from '../utils/animations';\n\n// Metro doesn't support dynamic imports - i.e. require() done in the component itself\n// But at the same time the following import will fail on Snack...\n// TODO: find a way to get React Native's version without having to assume the file path\n// import RN_PACKAGE from '../../../react-native/package.json';\n\nconst IS_ANDROID = Platform.OS === 'android';\n\n// Native driver for scroll events\n// See: https://facebook.github.io/react-native/blog/2017/02/14/using-native-driver-for-animated.html\nconst AnimatedFlatList = FlatList ? Animated.createAnimatedComponent(FlatList) : null;\nconst AnimatedScrollView = Animated.createAnimatedComponent(ScrollView);\n\n// React Native automatically handles RTL layouts; unfortunately, it's buggy with horizontal ScrollView\n// See https://github.com/facebook/react-native/issues/11960\n// NOTE: the following variable is not declared in the constructor\n// otherwise it is undefined at init, which messes with custom indexes\nconst IS_RTL = I18nManager.isRTL;\n\nexport default class Carousel extends Component {\n\n    static propTypes = {\n        data: PropTypes.array.isRequired,\n        renderItem: PropTypes.func.isRequired,\n        itemWidth: PropTypes.number, // required for horizontal carousel\n        itemHeight: PropTypes.number, // required for vertical carousel\n        sliderWidth: PropTypes.number, // required for horizontal carousel\n        sliderHeight: PropTypes.number, // required for vertical carousel\n        activeSlideAlignment: PropTypes.oneOf(['center', 'end', 'start']),\n        activeSlideOffset: PropTypes.number,\n        apparitionDelay: PropTypes.number,\n        autoplay: PropTypes.bool,\n        autoplayDelay: PropTypes.number,\n        autoplayInterval: PropTypes.number,\n        callbackOffsetMargin: PropTypes.number,\n        containerCustomStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        contentContainerCustomStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        enableSnap: PropTypes.bool,\n        firstItem: PropTypes.number,\n        hasParallaxImages: PropTypes.bool,\n        inactiveSlideOpacity: PropTypes.number,\n        inactiveSlideScale: PropTypes.number,\n        inactiveSlideShift: PropTypes.number,\n        layout: PropTypes.oneOf(['default', 'stack', 'tinder']),\n        layoutCardOffset: PropTypes.number,\n        loop: PropTypes.bool,\n        loopClonesPerSide: PropTypes.number,\n        scrollEnabled: PropTypes.bool,\n        scrollInterpolator: PropTypes.func,\n        slideInterpolatedStyle: PropTypes.func,\n        slideStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        shouldOptimizeUpdates: PropTypes.bool,\n        useExperimentalSnap: PropTypes.bool,\n        useScrollView: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n        vertical: PropTypes.bool,\n        onScrollIndexChanged: PropTypes.func,\n        onSnapToItem: PropTypes.func\n    };\n\n    static defaultProps = {\n        activeSlideAlignment: 'center',\n        activeSlideOffset: 20,\n        apparitionDelay: 0,\n        autoplay: false,\n        autoplayDelay: 1000,\n        autoplayInterval: 3000,\n        callbackOffsetMargin: 5,\n        containerCustomStyle: {},\n        contentContainerCustomStyle: {},\n        enableSnap: true,\n        firstItem: 0,\n        hasParallaxImages: false,\n        inactiveSlideOpacity: 0.7,\n        inactiveSlideScale: 0.9,\n        inactiveSlideShift: 0,\n        layout: 'default',\n        loop: false,\n        loopClonesPerSide: 3,\n        scrollEnabled: true,\n        slideStyle: {},\n        shouldOptimizeUpdates: true,\n        useExperimentalSnap: false,\n        useScrollView: !AnimatedFlatList,\n        vertical: false\n    }\n\n    constructor (props) {\n        super(props);\n\n        this.state = {\n            hideCarousel: !!props.apparitionDelay,\n            interpolators: []\n        };\n\n        // this._RNVersionCode = this._getRNVersionCode();\n\n        // The following values are not stored in the state because 'setState()' is asynchronous\n        // and this results in an absolutely crappy behavior on Android while swiping (see #156)\n        const initialActiveItem = this._getFirstItem(props.firstItem);\n        this._activeItem = initialActiveItem;\n        this._onScrollActiveItem = initialActiveItem;\n        this._previousFirstItem = initialActiveItem;\n        this._previousItemsLength = initialActiveItem;\n\n        this._mounted = false;\n        this._positions = [];\n        this._currentScrollOffset = 0; // Store ScrollView's scroll position\n        this._scrollEnabled = props.scrollEnabled !== false;\n\n        this._getCellRendererComponent = this._getCellRendererComponent.bind(this);\n        this._getItemLayout = this._getItemLayout.bind(this);\n        this._getKeyExtractor = this._getKeyExtractor.bind(this);\n        this._onLayout = this._onLayout.bind(this);\n        this._onScroll = this._onScroll.bind(this);\n        this._onMomentumScrollEnd = this._onMomentumScrollEnd.bind(this);\n        this._onTouchStart = this._onTouchStart.bind(this);\n        this._onTouchEnd = this._onTouchEnd.bind(this);\n        this._renderItem = this._renderItem.bind(this);\n\n        // WARNING: call this AFTER binding _onScroll\n        this._setScrollHandler(props);\n\n        // Display warnings\n        this._displayWarnings(props);\n    }\n\n    componentDidMount () {\n        const { apparitionDelay, autoplay, firstItem } = this.props;\n\n        this._mounted = true;\n        this._initPositionsAndInterpolators();\n\n        // Without 'requestAnimationFrame' or a `0` timeout, images will randomly not be rendered on Android...\n        this._initTimeout = setTimeout(() => {\n            if (!this._mounted) {\n                return;\n            }\n\n            const apparitionCallback = () => {\n                if (apparitionDelay) {\n                    this.setState({ hideCarousel: false });\n                }\n                if (autoplay) {\n                    this.startAutoplay();\n                }\n            };\n\n            // FlatList will use its own built-in prop `initialScrollIndex`\n            if (this._needsScrollView()) {\n                const _firstItem = this._getFirstItem(firstItem);\n                this._snapToItem(_firstItem, false, false, true);\n                // this._hackActiveSlideAnimation(_firstItem);\n            }\n\n            if (apparitionDelay) {\n                this._apparitionTimeout = setTimeout(() => {\n                    apparitionCallback();\n                }, apparitionDelay);\n            } else {\n                apparitionCallback();\n            }\n        }, 1);\n    }\n\n    shouldComponentUpdate (nextProps, nextState) {\n        if (this.props.shouldOptimizeUpdates === false) {\n            return true;\n        } else {\n            return shallowCompare(this, nextProps, nextState);\n        }\n    }\n\n    componentDidUpdate (prevProps) {\n        const { interpolators } = this.state;\n        const { firstItem, itemHeight, itemWidth, scrollEnabled, sliderHeight, sliderWidth } = this.props;\n        const itemsLength = this._getCustomDataLength(this.props);\n\n        if (!itemsLength) {\n            return;\n        }\n\n        const nextFirstItem = this._getFirstItem(firstItem, this.props);\n        let nextActiveItem = typeof this._activeItem !== 'undefined' ? this._activeItem : nextFirstItem;\n\n        const hasNewSliderWidth = sliderWidth && sliderWidth !== prevProps.sliderWidth;\n        const hasNewSliderHeight = sliderHeight && sliderHeight !== prevProps.sliderHeight;\n        const hasNewItemWidth = itemWidth && itemWidth !== prevProps.itemWidth;\n        const hasNewItemHeight = itemHeight && itemHeight !== prevProps.itemHeight;\n        const hasNewScrollEnabled = scrollEnabled !== prevProps.scrollEnabled;\n\n        // Prevent issues with dynamically removed items\n        if (nextActiveItem > itemsLength - 1) {\n            nextActiveItem = itemsLength - 1;\n        }\n\n        // Handle changing scrollEnabled independent of user -> carousel interaction\n        if (hasNewScrollEnabled) {\n            this._setScrollEnabled(scrollEnabled);\n        }\n\n        if (interpolators.length !== itemsLength || hasNewSliderWidth ||\n            hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {\n            this._activeItem = nextActiveItem;\n            this._previousItemsLength = itemsLength;\n\n            this._initPositionsAndInterpolators(this.props);\n\n            // Handle scroll issue when dynamically removing items (see #133)\n            // This also fixes first item's active state on Android\n            // Because 'initialScrollIndex' apparently doesn't trigger scroll\n            if (this._previousItemsLength > itemsLength) {\n                this._hackActiveSlideAnimation(nextActiveItem);\n            }\n\n            if (hasNewSliderWidth || hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {\n                this._snapToItem(nextActiveItem, false, false, true);\n            }\n        } else if (nextFirstItem !== this._previousFirstItem && nextFirstItem !== this._activeItem) {\n            this._activeItem = nextFirstItem;\n            this._previousFirstItem = nextFirstItem;\n            this._snapToItem(nextFirstItem, false, true, true);\n        }\n\n        if (this.props.onScroll !== prevProps.onScroll) {\n            this._setScrollHandler(this.props);\n        }\n    }\n\n    componentWillUnmount () {\n        this._mounted = false;\n        this.stopAutoplay();\n        clearTimeout(this._initTimeout);\n        clearTimeout(this._apparitionTimeout);\n        clearTimeout(this._hackSlideAnimationTimeout);\n        clearTimeout(this._enableAutoplayTimeout);\n        clearTimeout(this._autoplayTimeout);\n        clearTimeout(this._snapNoMomentumTimeout);\n        clearTimeout(this._androidRepositioningTimeout);\n    }\n\n    get realIndex () {\n        return this._activeItem;\n    }\n\n    get currentIndex () {\n        return this._getDataIndex(this._activeItem);\n    }\n\n    get currentScrollPosition () {\n        return this._currentScrollOffset;\n    }\n\n    _setScrollHandler (props) {\n        // Native driver for scroll events\n        const scrollEventConfig = {\n            listener: this._onScroll,\n            useNativeDriver: true\n        };\n        this._scrollPos = new Animated.Value(0);\n        const argMapping = props.vertical ?\n            [{ nativeEvent: { contentOffset: { y: this._scrollPos } } }] :\n            [{ nativeEvent: { contentOffset: { x: this._scrollPos } } }];\n\n        if (props.onScroll && Array.isArray(props.onScroll._argMapping)) {\n            // Because of a react-native issue https://github.com/facebook/react-native/issues/13294\n            argMapping.pop();\n            const [argMap] = props.onScroll._argMapping;\n            if (argMap && argMap.nativeEvent && argMap.nativeEvent.contentOffset) {\n                // Shares the same animated value passed in props\n                this._scrollPos =\n                argMap.nativeEvent.contentOffset.x ||\n                argMap.nativeEvent.contentOffset.y ||\n                this._scrollPos;\n            }\n            argMapping.push(...props.onScroll._argMapping);\n        }\n        this._onScrollHandler = Animated.event(\n            argMapping,\n            scrollEventConfig\n        );\n    }\n\n    // This will return a future-proof version code number compatible with semantic versioning\n    // Examples: 0.59.3 -> 5903 / 0.61.4 -> 6104 / 0.62.12 -> 6212 / 1.0.2 -> 10002\n    // _getRNVersionCode () {\n    //     const version = RN_PACKAGE && RN_PACKAGE.version;\n    //     if (!version) {\n    //         return null;\n    //     }\n    //     const versionSplit = version.split('.');\n    //     if (!versionSplit || !versionSplit.length) {\n    //         return null;\n    //     }\n    //     return versionSplit[0] * 10000 +\n    //         (typeof versionSplit[1] !== 'undefined' ? versionSplit[1] * 100 : 0) +\n    //         (typeof versionSplit[2] !== 'undefined' ? versionSplit[2] * 1 : 0);\n    // }\n\n    _displayWarnings (props = this.props) {\n        const pluginName = 'react-native-snap-carousel';\n        const removedProps = [\n            'activeAnimationType',\n            'activeAnimationOptions',\n            'enableMomentum',\n            'lockScrollTimeoutDuration',\n            'lockScrollWhileSnapping',\n            'onBeforeSnapToItem',\n            'swipeThreshold'\n        ];\n\n        // if (this._RNVersionCode && this._RNVersionCode < 5800) {\n        //     console.error(\n        //         `${pluginName}: Version 4+ of the plugin is based on React Native props that were introduced in version 0.58. ` +\n        //         'Please downgrade to version 3.x or update your version of React Native.'\n        //     );\n        // }\n        if (!props.vertical && (!props.sliderWidth || !props.itemWidth)) {\n            console.error(`${pluginName}: You need to specify both 'sliderWidth' and 'itemWidth' for horizontal carousels`);\n        }\n        if (props.vertical && (!props.sliderHeight || !props.itemHeight)) {\n            console.error(`${pluginName}: You need to specify both 'sliderHeight' and 'itemHeight' for vertical carousels`);\n        }\n\n        removedProps.forEach((removedProp) => {\n            if (props[removedProp]) {\n                console.warn(`${pluginName}: Prop ${removedProp} has been removed in version 4 of the plugin`);\n            }\n        });\n    }\n\n    _needsScrollView () {\n        const { useScrollView } = this.props;\n        // Android's cell renderer is buggy and has a stange overflow\n        // TODO: a workaround might be to pass the custom animated styles directly to it\n        return IS_ANDROID ?\n            useScrollView || !AnimatedFlatList || this._shouldUseStackLayout() || this._shouldUseTinderLayout() :\n            useScrollView || !AnimatedFlatList;\n    }\n\n    _needsRTLAdaptations () {\n        const { vertical } = this.props;\n        return IS_RTL && IS_ANDROID && !vertical;\n    }\n\n    _enableLoop () {\n        const { data, enableSnap, loop } = this.props;\n        return enableSnap && loop && data && data.length && data.length > 1;\n    }\n\n    _shouldAnimateSlides (props = this.props) {\n        const { inactiveSlideOpacity, inactiveSlideScale, scrollInterpolator, slideInterpolatedStyle } = props;\n        return inactiveSlideOpacity < 1 ||\n            inactiveSlideScale < 1 ||\n            !!scrollInterpolator ||\n            !!slideInterpolatedStyle ||\n            this._shouldUseShiftLayout() ||\n            this._shouldUseStackLayout() ||\n            this._shouldUseTinderLayout();\n    }\n\n    _shouldUseShiftLayout () {\n        const { inactiveSlideShift, layout } = this.props;\n        return layout === 'default' && inactiveSlideShift !== 0;\n    }\n\n    _shouldUseStackLayout () {\n        return this.props.layout === 'stack';\n    }\n\n    _shouldUseTinderLayout () {\n        return this.props.layout === 'tinder';\n    }\n\n    _shouldRepositionScroll (index) {\n        const { data, enableSnap, loopClonesPerSide } = this.props;\n        const dataLength = data && data.length;\n        if (!enableSnap || !dataLength || !this._enableLoop() ||\n            (index >= loopClonesPerSide && index < dataLength + loopClonesPerSide)) {\n            return false;\n        }\n        return true;\n    }\n\n    _roundNumber (num, decimals = 1) {\n        // https://stackoverflow.com/a/41716722/\n        const rounder = Math.pow(10, decimals);\n        return Math.round((num + Number.EPSILON) * rounder) / rounder;\n    }\n\n    _isMultiple (x, y) {\n        // This prevents Javascript precision issues: https://stackoverflow.com/a/58440614/\n        // Required because Android viewport size can return pretty complicated decimals numbers\n        return Math.round(Math.round(x / y) / (1 / y)) === Math.round(x);\n    }\n\n    _getCustomData (props = this.props) {\n        const { data, loopClonesPerSide } = props;\n        const dataLength = data && data.length;\n\n        if (!dataLength) {\n            return [];\n        }\n\n        if (!this._enableLoop()) {\n            return data;\n        }\n\n        let previousItems = [];\n        let nextItems = [];\n\n        if (loopClonesPerSide > dataLength) {\n            const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n            const remainder = loopClonesPerSide % dataLength;\n\n            for (let i = 0; i < dataMultiplier; i++) {\n                previousItems.push(...data);\n                nextItems.push(...data);\n            }\n\n            previousItems.unshift(...data.slice(-remainder));\n            nextItems.push(...data.slice(0, remainder));\n        } else {\n            previousItems = data.slice(-loopClonesPerSide);\n            nextItems = data.slice(0, loopClonesPerSide);\n        }\n\n        return previousItems.concat(data, nextItems);\n    }\n\n    _getCustomDataLength (props = this.props) {\n        const { data, loopClonesPerSide } = props;\n        const dataLength = data && data.length;\n\n        if (!dataLength) {\n            return 0;\n        }\n\n        return this._enableLoop() ? dataLength + (2 * loopClonesPerSide) : dataLength;\n    }\n\n    _getCustomIndex (index, props = this.props) {\n        const itemsLength = this._getCustomDataLength(props);\n\n        if (!itemsLength || typeof index === 'undefined') {\n            return 0;\n        }\n\n        return this._needsRTLAdaptations() ? itemsLength - index - 1 : index;\n    }\n\n    _getDataIndex (index) {\n        const { data, loopClonesPerSide } = this.props;\n        const dataLength = data && data.length;\n\n        if (!this._enableLoop() || !dataLength) {\n            return index;\n        }\n\n        if (index >= dataLength + loopClonesPerSide) {\n            return loopClonesPerSide > dataLength ?\n                (index - loopClonesPerSide) % dataLength :\n                index - dataLength - loopClonesPerSide;\n        } else if (index < loopClonesPerSide) {\n            // TODO: is there a simpler way of determining the interpolated index?\n            if (loopClonesPerSide > dataLength) {\n                const baseDataIndexes = [];\n                const dataIndexes = [];\n                const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n                const remainder = loopClonesPerSide % dataLength;\n\n                for (let i = 0; i < dataLength; i++) {\n                    baseDataIndexes.push(i);\n                }\n\n                for (let j = 0; j < dataMultiplier; j++) {\n                    dataIndexes.push(...baseDataIndexes);\n                }\n\n                dataIndexes.unshift(...baseDataIndexes.slice(-remainder));\n                return dataIndexes[index];\n            } else {\n                return index + dataLength - loopClonesPerSide;\n            }\n        } else {\n            return index - loopClonesPerSide;\n        }\n    }\n\n    // Used with `snapToItem()` and 'PaginationDot'\n    _getPositionIndex (index) {\n        const { loop, loopClonesPerSide } = this.props;\n        return loop ? index + loopClonesPerSide : index;\n    }\n\n    _getSnapOffsets (props = this.props) {\n        const offset = this._getItemMainDimension();\n        return [...Array(this._getCustomDataLength(props))].map((_, i) => {\n            return i * offset;\n        });\n    }\n\n    _getFirstItem (index, props = this.props) {\n        const { loopClonesPerSide } = props;\n        const itemsLength = this._getCustomDataLength(props);\n\n        if (!itemsLength || index > itemsLength - 1 || index < 0) {\n            return 0;\n        }\n\n        return this._enableLoop() ? index + loopClonesPerSide : index;\n    }\n\n    _getWrappedRef () {\n        // Starting with RN 0.62, we should no longer call `getNode()` on the ref of an Animated component\n        if (this._carouselRef && (\n            (this._needsScrollView() && this._carouselRef.scrollTo) ||\n            (!this._needsScrollView() && this._carouselRef.scrollToOffset)\n        )) {\n            return this._carouselRef;\n        }\n        // https://github.com/facebook/react-native/issues/10635\n        // https://stackoverflow.com/a/48786374/8412141\n        return this._carouselRef && this._carouselRef.getNode && this._carouselRef.getNode();\n    }\n\n    _getScrollEnabled () {\n        return this._scrollEnabled;\n    }\n\n    _setScrollEnabled (scrollEnabled = true) {\n        const wrappedRef = this._getWrappedRef();\n\n        if (!wrappedRef || !wrappedRef.setNativeProps) {\n            return;\n        }\n\n        // 'setNativeProps()' is used instead of 'setState()' because the latter\n        // really takes a toll on Android behavior when momentum is disabled\n        wrappedRef.setNativeProps({ scrollEnabled });\n        this._scrollEnabled = scrollEnabled;\n    }\n\n    _getItemMainDimension () {\n        const { itemWidth, itemHeight, vertical } = this.props;\n        return vertical ? itemHeight : itemWidth;\n    }\n\n    _getItemScrollOffset (index) {\n        return this._positions && this._positions[index] && this._positions[index].start;\n    }\n\n    _getItemLayout (_, index) {\n        const itemMainDimension = this._getItemMainDimension();\n        return {\n            index,\n            length: itemMainDimension,\n            offset: itemMainDimension * index // + this._getContainerInnerMargin()\n        };\n    }\n\n    // This will allow us to have a proper zIndex even with a FlatList\n    // https://github.com/facebook/react-native/issues/18616#issuecomment-389444165\n    _getCellRendererComponent ({ children, index, style, ...props }) {\n        const cellStyle = [\n            style,\n            !IS_ANDROID ? { zIndex: this._getCustomDataLength() - index } : {}\n        ];\n\n        return (\n            <View style={cellStyle} index={index} {...props}>\n                {children}\n            </View>\n        );\n    }\n\n    _getKeyExtractor (_, index) {\n        return this._needsScrollView() ? `scrollview-item-${index}` : `flatlist-item-${index}`;\n    }\n\n    _getScrollOffset (event) {\n        const { vertical } = this.props;\n        return (event && event.nativeEvent && event.nativeEvent.contentOffset &&\n            event.nativeEvent.contentOffset[vertical ? 'y' : 'x']) || 0;\n    }\n\n    _getContainerInnerMargin (opposite = false) {\n        const { sliderWidth, sliderHeight, itemWidth, itemHeight, vertical, activeSlideAlignment } = this.props;\n\n        if ((activeSlideAlignment === 'start' && !opposite) ||\n            (activeSlideAlignment === 'end' && opposite)) {\n            return 0;\n        } else if ((activeSlideAlignment === 'end' && !opposite) ||\n            (activeSlideAlignment === 'start' && opposite)) {\n            return vertical ? sliderHeight - itemHeight : sliderWidth - itemWidth;\n        } else {\n            return vertical ? (sliderHeight - itemHeight) / 2 : (sliderWidth - itemWidth) / 2;\n        }\n    }\n\n    _getActiveSlideOffset () {\n        const { activeSlideOffset } = this.props;\n        const itemMainDimension = this._getItemMainDimension();\n        const minOffset = 10;\n        // Make sure activeSlideOffset never prevents the active area from being at least 10 px wide\n        return itemMainDimension / 2 - activeSlideOffset >= minOffset ? activeSlideOffset : minOffset;\n    }\n\n    _getActiveItem (offset) {\n        const itemMainDimension = this._getItemMainDimension();\n        const center = offset + itemMainDimension / 2;\n        const activeSlideOffset = this._getActiveSlideOffset();\n        const lastIndex = this._positions.length - 1;\n        let itemIndex;\n\n        if (offset <= 0) {\n            return 0;\n        }\n\n        if (this._positions[lastIndex] && offset >= this._positions[lastIndex].start) {\n            return lastIndex;\n        }\n\n        for (let i = 0; i < this._positions.length; i++) {\n            const { start, end } = this._positions[i];\n            if (center + activeSlideOffset >= start && center - activeSlideOffset <= end) {\n                itemIndex = i;\n                break;\n            }\n        }\n\n        return itemIndex || 0;\n    }\n\n    _getSlideInterpolatedStyle (index, animatedValue) {\n        const { layoutCardOffset, slideInterpolatedStyle } = this.props;\n\n        if (slideInterpolatedStyle) {\n            return slideInterpolatedStyle(index, animatedValue, this.props);\n        } else if (this._shouldUseTinderLayout()) {\n            return tinderAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);\n        } else if (this._shouldUseStackLayout()) {\n            return stackAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);\n        } else if (this._shouldUseShiftLayout()) {\n            return shiftAnimatedStyles(index, animatedValue, this.props);\n        } else {\n            return defaultAnimatedStyles(index, animatedValue, this.props);\n        }\n    }\n\n    _initPositionsAndInterpolators (props = this.props) {\n        const { data, scrollInterpolator } = props;\n        const itemMainDimension = this._getItemMainDimension();\n\n        if (!data || !data.length) {\n            return;\n        }\n\n        const interpolators = [];\n        this._positions = [];\n\n        this._getCustomData(props).forEach((itemData, index) => {\n            const _index = this._getCustomIndex(index, props);\n            let animatedValue;\n\n            this._positions[index] = {\n                start: index * itemMainDimension,\n                end: index * itemMainDimension + itemMainDimension\n            };\n\n            if (!this._shouldAnimateSlides(props)) {\n                animatedValue = new Animated.Value(1);\n            } else {\n                let interpolator;\n\n                if (scrollInterpolator) {\n                    interpolator = scrollInterpolator(_index, props);\n                } else if (this._shouldUseStackLayout()) {\n                    interpolator = stackScrollInterpolator(_index, props);\n                } else if (this._shouldUseTinderLayout()) {\n                    interpolator = tinderScrollInterpolator(_index, props);\n                }\n\n                if (!interpolator || !interpolator.inputRange || !interpolator.outputRange) {\n                    interpolator = defaultScrollInterpolator(_index, props);\n                }\n\n                animatedValue = this._scrollPos.interpolate({\n                    ...interpolator,\n                    extrapolate: 'clamp'\n                });\n            }\n\n            interpolators.push(animatedValue);\n        });\n\n        this.setState({ interpolators });\n    }\n\n    _hackActiveSlideAnimation (index, scrollValue = 1) {\n        const offset = this._getItemScrollOffset(index);\n\n        if (!this._mounted || !this._carouselRef || typeof offset === 'undefined') {\n            return;\n        }\n\n        const multiplier = this._currentScrollOffset === 0 ? 1 : -1;\n        const scrollDelta = scrollValue * multiplier;\n\n        this._scrollTo({ offset: offset + scrollDelta, animated: false });\n\n        clearTimeout(this._hackSlideAnimationTimeout);\n        this._hackSlideAnimationTimeout = setTimeout(() => {\n            this._scrollTo({ offset, animated: false });\n        }, 1); // works randomly when set to '0'\n    }\n\n    _repositionScroll (index, animated = false) {\n        const { data, loopClonesPerSide } = this.props;\n        const dataLength = data && data.length;\n\n        if (typeof index === 'undefined' || !this._shouldRepositionScroll(index)) {\n            return;\n        }\n\n        let repositionTo = index;\n\n        if (index >= dataLength + loopClonesPerSide) {\n            repositionTo = index - dataLength;\n        } else if (index < loopClonesPerSide) {\n            repositionTo = index + dataLength;\n        }\n\n        this._snapToItem(repositionTo, animated, false);\n    }\n\n    _scrollTo ({ offset, index, animated = true }) {\n        const { vertical } = this.props;\n        const wrappedRef = this._getWrappedRef();\n        if (!this._mounted || !wrappedRef || (typeof offset === 'undefined' && typeof index === 'undefined')) {\n            return;\n        }\n\n        let scrollToOffset;\n        if (typeof index !== 'undefined') {\n            scrollToOffset = this._getItemScrollOffset(index);\n        } else {\n            scrollToOffset = offset;\n        }\n\n        if (typeof scrollToOffset === 'undefined') {\n            return;\n        }\n\n        const options = this._needsScrollView() ? {\n            x: vertical ? 0 : offset,\n            y: vertical ? offset : 0,\n            animated\n        } : {\n            offset,\n            animated\n        };\n\n        if (this._needsScrollView()) {\n            wrappedRef.scrollTo(options);\n        } else {\n            wrappedRef.scrollToOffset(options);\n        }\n    }\n\n    _onTouchStart () {\n        const { onTouchStart } = this.props;\n\n        // `onTouchStart` is fired even when `scrollEnabled` is set to `false`\n        if (this._getScrollEnabled() !== false && this._autoplaying) {\n            this.pauseAutoPlay();\n        }\n\n        onTouchStart && onTouchStart();\n    }\n\n    _onTouchEnd () {\n        const { onTouchEnd } = this.props;\n\n        if (this._getScrollEnabled() !== false && this._autoplay && !this._autoplaying) {\n            // This event is buggy on Android, so a fallback is provided in _onMomentumScrollEnd()\n            this.startAutoplay();\n        }\n\n        onTouchEnd && onTouchEnd();\n    }\n\n    _onScroll (event) {\n        const { onScroll, onScrollIndexChanged } = this.props;\n        const scrollOffset = event ? this._getScrollOffset(event) : this._currentScrollOffset;\n        const nextActiveItem = this._getActiveItem(scrollOffset);\n\n        this._currentScrollOffset = scrollOffset;\n\n        if (nextActiveItem !== this._onScrollActiveItem) {\n            this._onScrollActiveItem = nextActiveItem;\n            onScrollIndexChanged && onScrollIndexChanged(this._getDataIndex(nextActiveItem));\n        }\n\n        if (typeof onScroll === 'function' && event) {\n            onScroll(event);\n        }\n    }\n\n    _onMomentumScrollEnd (event) {\n        const { autoplayDelay, itemWidth, onMomentumScrollEnd, onSnapToItem } = this.props;\n        const scrollOffset = event ? this._getScrollOffset(event) : this._currentScrollOffset;\n        const nextActiveItem = this._getActiveItem(scrollOffset);\n        const hasSnapped = this._isMultiple(scrollOffset, itemWidth);\n\n        // WARNING: everything in this condition will probably need to be called on _snapToItem as well because:\n        // 1. `onMomentumScrollEnd` won't be called if the scroll isn't animated\n        // 2. `onMomentumScrollEnd` won't be called at all on Android when scrolling programmatically\n        if (nextActiveItem !== this._activeItem) {\n            this._activeItem = nextActiveItem;\n            onSnapToItem && onSnapToItem(this._getDataIndex(nextActiveItem));\n\n            if (hasSnapped) {\n                this._repositionScroll(nextActiveItem);\n            }\n        }\n\n        onMomentumScrollEnd && onMomentumScrollEnd(event);\n\n        // The touchEnd event is buggy on Android, so this will serve as a fallback whenever needed\n        // https://github.com/facebook/react-native/issues/9439\n        if (IS_ANDROID && this._autoplay && !this._autoplaying) {\n            clearTimeout(this._enableAutoplayTimeout);\n            this._enableAutoplayTimeout = setTimeout(() => {\n                this.startAutoplay();\n            }, autoplayDelay);\n        }\n\n    }\n\n    _onLayout (event) {\n        const { onLayout } = this.props;\n\n        // Prevent unneeded actions during the first 'onLayout' (triggered on init)\n        if (this._onLayoutInitDone) {\n            this._initPositionsAndInterpolators();\n            this._snapToItem(this._activeItem, false, false, true);\n        } else {\n            this._onLayoutInitDone = true;\n        }\n\n        onLayout && onLayout(event);\n    }\n\n    _snapToItem (index, animated = true, fireCallback = true, forceScrollTo = false) {\n        const { onSnapToItem } = this.props;\n        const itemsLength = this._getCustomDataLength();\n        const wrappedRef = this._getWrappedRef();\n\n        if (!itemsLength || !wrappedRef) {\n            return;\n        }\n\n        if (!index || index < 0) {\n            index = 0;\n        } else if (itemsLength > 0 && index >= itemsLength) {\n            index = itemsLength - 1;\n        }\n\n        if (index === this._activeItem && !forceScrollTo) {\n            return;\n        }\n\n        const offset = this._getItemScrollOffset(index);\n\n        if (offset === undefined) {\n            return;\n        }\n\n        this._scrollTo({ offset, animated });\n\n        // On both platforms, `onMomentumScrollEnd` won't be triggered if the scroll isn't animated\n        // so we need to trigger the callback manually\n        // On Android `onMomentumScrollEnd` won't be triggered when scrolling programmatically\n        // Therefore everything critical needs to be manually called here as well, even though the timing might be off\n        const requiresManualTrigger = !animated || IS_ANDROID;\n        if (requiresManualTrigger) {\n            this._activeItem = index;\n\n            if (fireCallback) {\n                onSnapToItem && onSnapToItem(this._getDataIndex(index));\n            }\n\n            // Repositioning on Android\n            if (IS_ANDROID && this._shouldRepositionScroll(index)) {\n                if (animated) {\n                    this._androidRepositioningTimeout = setTimeout(() => {\n                        // Without scroll animation, the behavior is completely buggy...\n                        this._repositionScroll(index, true);\n                    }, 400); // Approximate scroll duration on Android\n                } else {\n                    this._repositionScroll(index);\n                }\n            }\n        }\n    }\n\n    startAutoplay () {\n        const { autoplayInterval, autoplayDelay } = this.props;\n        this._autoplay = true;\n\n        if (this._autoplaying) {\n            return;\n        }\n\n        clearTimeout(this._autoplayTimeout);\n        this._autoplayTimeout = setTimeout(() => {\n            this._autoplaying = true;\n            this._autoplayInterval = setInterval(() => {\n                if (this._autoplaying) {\n                    this.snapToNext();\n                }\n            }, autoplayInterval);\n        }, autoplayDelay);\n    }\n\n    pauseAutoPlay () {\n        this._autoplaying = false;\n        clearTimeout(this._autoplayTimeout);\n        clearTimeout(this._enableAutoplayTimeout);\n        clearInterval(this._autoplayInterval);\n    }\n\n    stopAutoplay () {\n        this._autoplay = false;\n        this.pauseAutoPlay();\n    }\n\n    snapToItem (index, animated = true, fireCallback = true) {\n        if (!index || index < 0) {\n            index = 0;\n        }\n\n        const positionIndex = this._getPositionIndex(index);\n\n        if (positionIndex === this._activeItem) {\n            return;\n        }\n\n        this._snapToItem(positionIndex, animated, fireCallback);\n    }\n\n    snapToNext (animated = true, fireCallback = true) {\n        const itemsLength = this._getCustomDataLength();\n\n        let newIndex = this._activeItem + 1;\n        if (newIndex > itemsLength - 1) {\n            newIndex = 0;\n        }\n        this._snapToItem(newIndex, animated, fireCallback);\n    }\n\n    snapToPrev (animated = true, fireCallback = true) {\n        const itemsLength = this._getCustomDataLength();\n\n        let newIndex = this._activeItem - 1;\n        if (newIndex < 0) {\n            newIndex = itemsLength - 1;\n        }\n        this._snapToItem(newIndex, animated, fireCallback);\n    }\n\n    // https://github.com/facebook/react-native/issues/1831#issuecomment-231069668\n    triggerRenderingHack (offset = 1) {\n        this._hackActiveSlideAnimation(this._activeItem, offset);\n    }\n\n    _renderItem ({ item, index }) {\n        const { interpolators } = this.state;\n        const {\n            hasParallaxImages, itemWidth, itemHeight, keyExtractor, renderItem,\n            sliderHeight, sliderWidth, slideStyle, vertical\n        } = this.props;\n        const animatedValue = interpolators && interpolators[index];\n\n        if (typeof animatedValue === 'undefined') {\n            return null;\n        }\n\n        const animate = this._shouldAnimateSlides();\n        const Component = animate ? Animated.View : View;\n        const animatedStyle = animate ? this._getSlideInterpolatedStyle(index, animatedValue) : {};\n        const dataIndex = this._getDataIndex(index);\n\n        const parallaxProps = hasParallaxImages ? {\n            scrollPosition: this._scrollPos,\n            carouselRef: this._carouselRef,\n            vertical,\n            sliderWidth,\n            sliderHeight,\n            itemWidth,\n            itemHeight\n        } : undefined;\n\n        const mainDimension = vertical ? { height: itemHeight } : { width: itemWidth };\n        const specificProps = this._needsScrollView() ? {\n            key: keyExtractor ? keyExtractor(item, index) : this._getKeyExtractor(item, index)\n        } : {};\n\n        return (\n            <Component style={[mainDimension, slideStyle, animatedStyle]} pointerEvents={'box-none'} {...specificProps}>\n                { renderItem({ item, index, dataIndex }, parallaxProps) }\n            </Component>\n        );\n    }\n\n    _getComponentOverridableProps () {\n        const { hideCarousel } = this.state;\n        const {\n            itemWidth, itemHeight, loopClonesPerSide,\n            sliderWidth, sliderHeight, vertical\n        } = this.props;\n        const visibleItems = Math.ceil(vertical ? sliderHeight / itemHeight : sliderWidth / itemWidth) + 1;\n        const initialNumPerSide = this._enableLoop() ? loopClonesPerSide : 2;\n        const initialNumToRender = visibleItems + (initialNumPerSide * 2);\n        const maxToRenderPerBatch = initialNumToRender + (initialNumPerSide * 2);\n        const windowSize = maxToRenderPerBatch;\n\n        const specificProps = !this._needsScrollView() ? {\n            initialNumToRender,\n            maxToRenderPerBatch,\n            windowSize\n            // updateCellsBatchingPeriod\n        } : {};\n\n        return {\n            ...specificProps,\n            automaticallyAdjustContentInsets: false,\n            decelerationRate: 'fast',\n            directionalLockEnabled: true,\n            disableScrollViewPanResponder: false, // If set to `true`, touch events will be triggered too easily\n            inverted: this._needsRTLAdaptations(),\n            overScrollMode: 'never',\n            pinchGestureEnabled: false,\n            pointerEvents: hideCarousel ? 'none' : 'auto',\n            // removeClippedSubviews: !this._needsScrollView(),\n            // renderToHardwareTextureAndroid: true,\n            scrollsToTop: false,\n            showsHorizontalScrollIndicator: false,\n            showsVerticalScrollIndicator: false\n        };\n    }\n\n    _getComponentStaticProps () {\n        const { hideCarousel } = this.state;\n        const {\n            activeSlideAlignment, CellRendererComponent, containerCustomStyle,\n            contentContainerCustomStyle, firstItem, getItemLayout, keyExtractor,\n            sliderWidth, sliderHeight, style, useExperimentalSnap, vertical\n        } = this.props;\n\n        const containerStyle = [\n            // { overflow: 'hidden' },\n            containerCustomStyle || style || {},\n            hideCarousel ? { opacity: 0 } : {},\n            vertical ?\n                { height: sliderHeight, flexDirection: 'column' } :\n                // LTR hack; see https://github.com/facebook/react-native/issues/11960\n                // and https://github.com/facebook/react-native/issues/13100#issuecomment-328986423\n                { width: sliderWidth, flexDirection: this._needsRTLAdaptations() ? 'row-reverse' : 'row' }\n        ];\n\n        const innerMarginStyle = vertical ? {\n            paddingTop: this._getContainerInnerMargin(),\n            paddingBottom: this._getContainerInnerMargin(true)\n        } : {\n            paddingLeft: this._getContainerInnerMargin(),\n            paddingRight: this._getContainerInnerMargin(true)\n        };\n\n        const contentContainerStyle = [\n            !useExperimentalSnap ? innerMarginStyle : {},\n            contentContainerCustomStyle || {}\n        ];\n\n        // WARNING: `snapToAlignment` won't work as intended because of the following:\n        // https://github.com/facebook/react-native/blob/d0871d0a9a373e1d3ac35da46c85c0d0e793116d/React/Views/ScrollView/RCTScrollView.m#L751-L755\n        // - Snap points will be off\n        // - Slide animations will be off\n        // - Last items won't be set as active (no `onSnapToItem` callback)\n        // Recommended only with large slides and `activeSlideAlignment` set to `start` for the time being\n        const snapProps = useExperimentalSnap ? {\n            // disableIntervalMomentum: true, // Slide  one item at a time\n            snapToAlignment: activeSlideAlignment,\n            snapToInterval: this._getItemMainDimension()\n        } : {\n            snapToOffsets: this._getSnapOffsets()\n        };\n\n        // Flatlist specifics\n        const specificProps = !this._needsScrollView() ? {\n            CellRendererComponent: CellRendererComponent || this._getCellRendererComponent,\n            getItemLayout: getItemLayout || this._getItemLayout,\n            initialScrollIndex: this._getFirstItem(firstItem),\n            keyExtractor: keyExtractor || this._getKeyExtractor,\n            numColumns: 1,\n            renderItem: this._renderItem\n        } : {};\n\n        return {\n            ...specificProps,\n            ...snapProps,\n            ref: (c) => { this._carouselRef = c; },\n            contentContainerStyle: contentContainerStyle,\n            data: this._getCustomData(),\n            horizontal: !vertical,\n            scrollEventThrottle: 1,\n            style: containerStyle,\n            onLayout: this._onLayout,\n            onMomentumScrollEnd: this._onMomentumScrollEnd,\n            onScroll: this._onScrollHandler,\n            onTouchStart: this._onTouchStart,\n            onTouchEnd: this._onTouchEnd\n        };\n    }\n\n    render () {\n        const { data, renderItem, useScrollView } = this.props;\n\n        if (!data || !renderItem) {\n            return null;\n        }\n\n        const props = {\n            ...this._getComponentOverridableProps(),\n            ...this.props,\n            ...this._getComponentStaticProps()\n        };\n\n        const ScrollViewComponent = typeof useScrollView === 'function' ? useScrollView : AnimatedScrollView;\n\n        return this._needsScrollView() ? (\n            <ScrollViewComponent {...props}>\n                {\n                    this._getCustomData().map((item, index) => {\n                        return this._renderItem({ item, index });\n                    })\n                }\n            </ScrollViewComponent>\n        ) : (\n            <AnimatedFlatList {...props} />\n        );\n    }\n}\n"]},"metadata":{},"sourceType":"script"}